

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8. Type Inference &#8212; Foundations of Programming Languages Second Edition</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="7. Prolog" href="prolog.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="prolog.html" title="7. Prolog"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Foundations of Programming Languages Second Edition</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Type Inference</a><ul>
<li><a class="reference internal" href="#why-static-type-inference">8.1. Why Static Type Inference?</a></li>
<li><a class="reference internal" href="#type-inference-rules">8.2. Type Inference Rules</a></li>
<li><a class="reference internal" href="#using-prolog">8.3. Using Prolog</a></li>
<li><a class="reference internal" href="#the-type-environment">8.4. The Type Environment</a></li>
<li><a class="reference internal" href="#integers-strings-and-boolean-constants">8.5. Integers, Strings, and Boolean Constants</a><ul>
<li><a class="reference internal" href="#example-8-1">8.5.1. Example 8.1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#list-and-tuple-constants">8.6. List and Tuple Constants</a><ul>
<li><a class="reference internal" href="#example-8-2">8.6.1. Example 8.2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#identifiers">8.7. Identifiers</a><ul>
<li><a class="reference internal" href="#example-8-3">8.7.1. Example 8.3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-application">8.8. Function Application</a><ul>
<li><a class="reference internal" href="#instantiation">8.8.1. Instantiation</a></li>
<li><a class="reference internal" href="#example-8-4">8.8.2. Example 8.4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#let-expressions">8.9. Let Expressions</a><ul>
<li><a class="reference internal" href="#example-8-5">8.9.1. Example 8.5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#patterns">8.10. Patterns</a><ul>
<li><a class="reference internal" href="#example-8-6">8.10.1. Example 8.6</a></li>
</ul>
</li>
<li><a class="reference internal" href="#matches">8.11. Matches</a><ul>
<li><a class="reference internal" href="#example-8-7">8.11.1. Example 8.7</a></li>
</ul>
</li>
<li><a class="reference internal" href="#anonymous-functions">8.12. Anonymous Functions</a><ul>
<li><a class="reference internal" href="#example-8-8">8.12.1. Example 8.8</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequential-execution">8.13. Sequential Execution</a></li>
<li><a class="reference internal" href="#if-then-and-while-do">8.14. If-Then and While-Do</a></li>
<li><a class="reference internal" href="#exception-handling">8.15. Exception Handling</a></li>
<li><a class="reference internal" href="#chapter-summary">8.16. Chapter Summary</a></li>
<li><a class="reference internal" href="#review-questions">8.17. Review Questions</a></li>
<li><a class="reference internal" href="#exercises">8.18. Exercises</a></li>
<li><a class="reference internal" href="#solutions-to-practice-problems">8.19. Solutions to Practice Problems</a><ul>
<li><a class="reference internal" href="#solution-to-practice-problem-8-1">8.19.1. Solution to Practice Problem 8.1</a></li>
<li><a class="reference internal" href="#solution-to-practice-problem-8-2">8.19.2. Solution to Practice Problem 8.2</a></li>
<li><a class="reference internal" href="#solution-to-practice-problem-8-3">8.19.3. Solution to Practice Problem 8.3</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="prolog.html"
                        title="previous chapter">7. Prolog</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/typeinference.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="type-inference">
<h1>8. Type Inference<a class="headerlink" href="#type-inference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="why-static-type-inference">
<h2>8.1. Why Static Type Inference?<a class="headerlink" href="#why-static-type-inference" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="kr">in</span>
  <span class="n">x</span> <span class="n">:=</span> <span class="n">!x</span> <span class="n">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">!x</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig 8.1</strong> test8.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="kr">in</span>
  <span class="n">x</span> <span class="n">:=</span> <span class="n">x</span> <span class="n">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig 8.2</strong> test13.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">exception</span> <span class="nc">E</span> <span class="kr">of</span> <span class="n">int</span><span class="p">;</span>
<span class="kr">fun</span> <span class="nf">g</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="kr">raise</span> <span class="n">E</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="kr">fun</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=</span>
    <span class="kr">let</span>
      <span class="kr">exception</span> <span class="nc">E</span> <span class="kr">of</span> <span class="n">real</span><span class="p">;</span>
      <span class="kr">fun</span> <span class="nf">z</span><span class="p">(</span><span class="n">y</span><span class="p">)=</span> <span class="kr">raise</span> <span class="n">E</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="kr">in</span>
      <span class="n">x</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>
      <span class="n">z</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="kr">end</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 8.3</strong> Exception Program</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>stdIn:216.8-216.12 Error: operator and operand don&#39;t agree [literal]
  operator domain: real
  operand:         int
  in expression:
    z 3
</pre></div>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">6</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="n">x</span>
  <span class="n">println</span> <span class="s2">&quot;Done&quot;</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig 8.4</strong> A bad function call</p>
</div>
</div>
<div class="section" id="type-inference-rules">
<h2>8.2. Type Inference Rules<a class="headerlink" href="#type-inference-rules" title="Permalink to this headline">¶</a></h2>
<p><strong>RuleName</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/fdca1f0dfa80da6d2b6f2e5c69f7459cd5e311cd.png" alt="\frac{Premise_1,~~Premise_2,~~...,~~Premise_n}{Conclusion}"/></p>
</div></div></blockquote>
</div>
<div class="section" id="using-prolog">
<h2>8.3. Using Prolog<a class="headerlink" href="#using-prolog" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<blockquote>
<div><div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">letdec</span><span class="p">(</span>
      <span class="nf">bindval</span><span class="p">(</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;ref&#39;</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="s s-Atom">&#39;0&#39;</span><span class="p">))),</span>
  <span class="p">[</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;:=&#39;</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">),</span>
   <span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;+&#39;</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;!&#39;</span><span class="p">),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">)),</span>
         <span class="nf">int</span><span class="p">(</span><span class="s s-Atom">&#39;1&#39;</span><span class="p">)]))])),</span>
   <span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;println&#39;</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;!&#39;</span><span class="p">),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">)))</span>
  <span class="p">]).</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>Fig. 8.5</strong> test8.sml prolog AST</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">finalStatus</span><span class="p">(</span><span class="s s-Atom">typeerror</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;The program failed to pass the typechecker.&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="p">!.</span>
<span class="nf">finalStatus</span><span class="p">(</span><span class="k">_</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;The program passed the typechecker.&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="p">!.</span>

<span class="nf">warning</span><span class="p">([],</span><span class="k">_</span><span class="p">)</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">warning</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="k">_</span><span class="p">))</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">warning</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="k">_</span><span class="p">],</span><span class="k">_</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Warning: type vars not instantiated in result type initialized to dummy types!&#39;</span><span class="p">),</span>
  <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="p">!.</span>

<span class="nf">errorOut</span><span class="p">(</span><span class="nf">error</span><span class="p">(</span><span class="nv">E</span><span class="p">))</span> <span class="p">:-</span>
     <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Error: Typechecking failed. Message was : &#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
     <span class="nf">print</span><span class="p">(</span><span class="nv">E</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">halt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">errorOut</span><span class="p">(</span><span class="nf">typeerror</span><span class="p">(</span><span class="nv">E</span><span class="p">))</span> <span class="p">:-</span>
     <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Error: Typechecking failed due to type error. Message was : &#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
     <span class="nf">print</span><span class="p">(</span><span class="nv">E</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">halt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">errorOut</span><span class="p">(</span><span class="nv">E</span><span class="p">)</span> <span class="p">:-</span>
     <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Error: Typechecking failed for unknown reason : &#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
     <span class="nf">print</span><span class="p">(</span><span class="nv">E</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">halt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>
<span class="nf">run</span> <span class="o">:-</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Typechecking is commencing...&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
       <span class="nf">readAST</span><span class="p">(</span><span class="nv">AST</span><span class="p">),</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Here is the AST&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">print</span><span class="p">(</span><span class="nv">AST</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span>
       <span class="nf">catch</span><span class="p">(</span><span class="nf">typecheckProgram</span><span class="p">(</span><span class="nv">AST</span><span class="p">,</span><span class="nv">Type</span><span class="p">),</span><span class="nv">E</span><span class="p">,</span><span class="nf">errorOut</span><span class="p">(</span><span class="nv">E</span><span class="p">)),</span>
       <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;val it : &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">Type</span><span class="p">,</span><span class="nv">TypeVars</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span> <span class="s s-Atom">nl</span><span class="p">,</span>
       <span class="nf">warning</span><span class="p">(</span><span class="nv">TypeVars</span><span class="p">,</span><span class="nv">Type</span><span class="p">),</span> <span class="nf">finalStatus</span><span class="p">(</span><span class="nv">Type</span><span class="p">).</span>
<span class="nf">runNonInteractive</span> <span class="o">:-</span> <span class="s s-Atom">run</span><span class="p">,</span> <span class="nf">halt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 8.6</strong> The Type Checker run Predicate</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">datatype</span>
  <span class="kt">exp</span> <span class="p">=</span> <span class="nc">int</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">ch</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">str</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">bool</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">id</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">listcon</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">tuplecon</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">apply</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">expsequence</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">letdec</span> <span class="kr">of</span> <span class="n">dec</span> <span class="n">*</span> <span class="p">(</span><span class="n">exp</span> <span class="n">list</span><span class="p">)</span>
      <span class="p">|</span> <span class="nc">handlexp</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">ifthen</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">whiledo</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">func</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
<span class="kr">and</span>
  <span class="kt">match</span> <span class="p">=</span> <span class="nc">match</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
<span class="kr">and</span>
  <span class="kt">pat</span> <span class="p">=</span> <span class="nc">intpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">chpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">strpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">boolpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">idpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">wildcardpat</span>
      <span class="p">|</span> <span class="nc">infixpat</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">pat</span>
      <span class="p">|</span> <span class="nc">tuplepat</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">listpat</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">aspat</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">pat</span>
<span class="kr">and</span>
  <span class="kt">dec</span> <span class="p">=</span> <span class="nc">bindval</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">bindvalrec</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">funmatch</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">funmatches</span> <span class="kr">of</span> <span class="p">(</span><span class="n">string</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span><span class="p">)</span> <span class="n">list</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 8.7</strong> AST Description</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>type = bool
     | int
     | str
     | exn
     | tuple of type list
     | listOf of type
     | fn of type * type
     | ref of type
     | typevar of string
     | typeerror
</pre></div>
</div>
<p><strong>Fig. 8.8</strong> Small Types</p>
</div>
</div>
<div class="section" id="the-type-environment">
<h2>8.4. The Type Environment<a class="headerlink" href="#the-type-environment" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">typecheckProgram</span><span class="p">(</span><span class="nv">Expression</span><span class="p">,</span><span class="nv">Type</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">typecheckExp</span><span class="p">([(</span><span class="s s-Atom">&#39;Exception&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="s s-Atom">exn</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;raise&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="s s-Atom">exn</span><span class="p">,</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;andalso&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">bool</span><span class="p">,</span><span class="s s-Atom">bool</span><span class="p">]),</span><span class="s s-Atom">bool</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;orelse&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">bool</span><span class="p">,</span><span class="s s-Atom">bool</span><span class="p">]),</span><span class="s s-Atom">bool</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;:=&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">ref</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)),</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)]),</span><span class="nf">tuple</span><span class="p">([]))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;!&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">ref</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)),</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;ref&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">ref</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;::&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">listOf</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">))]),</span><span class="nf">listOf</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;&gt;&#39;</span><span class="p">,</span> <span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)]),</span><span class="s s-Atom">bool</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;&lt;&#39;</span><span class="p">,</span> <span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)]),</span><span class="s s-Atom">bool</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">@</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">listOf</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)),</span><span class="nf">listOf</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">))]),</span><span class="nf">listOf</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">)))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;Int.fromString&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="s s-Atom">str</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;input&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="s s-Atom">str</span><span class="p">,</span><span class="s s-Atom">str</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;explode&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="s s-Atom">str</span><span class="p">,</span><span class="nf">listOf</span><span class="p">(</span><span class="s s-Atom">str</span><span class="p">))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;implode&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">listOf</span><span class="p">(</span><span class="s s-Atom">str</span><span class="p">),</span><span class="s s-Atom">str</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;println&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([]))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;print&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([]))),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;cprint&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="s s-Atom">cprint</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;type&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">typevar</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span> <span class="s s-Atom">str</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">+</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">]),</span><span class="s s-Atom">int</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">-</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">]),</span><span class="s s-Atom">int</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">]),</span><span class="s s-Atom">int</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s s-Atom">&#39;div&#39;</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">]),</span><span class="s s-Atom">int</span><span class="p">))],</span>
           <span class="nv">Expression</span><span class="p">,</span><span class="nv">Type</span><span class="p">).</span>
</pre></div>
</div>
<p><strong>Fig. 8.9</strong> The Prolog Type Environment</p>
</div>
</div>
<div class="section" id="integers-strings-and-boolean-constants">
<h2>8.5. Integers, Strings, and Boolean Constants<a class="headerlink" href="#integers-strings-and-boolean-constants" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">typecheckExp</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="k">_</span><span class="p">),</span><span class="s s-Atom">int</span><span class="p">).</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nf">bool</span><span class="p">(</span><span class="k">_</span><span class="p">),</span><span class="s s-Atom">bool</span><span class="p">).</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nf">str</span><span class="p">(</span><span class="k">_</span><span class="p">),</span><span class="s s-Atom">str</span><span class="p">).</span>
</pre></div>
</div>
<p><strong>Fig. 8.10</strong> Constant Types</p>
</div>
<p><strong>BoolCon</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/1e72da88ac538f0a75e00a8ebe6017d4b841314b.png" alt="\frac{}{\varepsilon\vdash bool(v) : bool}"/></p>
</div></div></blockquote>
<p><strong>IntCon</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/6ddee863680816f225ef3d19ee387178bdab182d.png" alt="\frac{}{\varepsilon\vdash int(v) : int}"/></p>
</div></div></blockquote>
<p><strong>StringCon</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/091c7a5a838488fdc8e40439322531db4a0971e8.png" alt="\frac{}{\varepsilon\vdash str(v) : str}"/></p>
</div></div></blockquote>
<div class="section" id="example-8-1">
<h3>8.5.1. Example 8.1<a class="headerlink" href="#example-8-1" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Typechecking is commencing...
Here is the AST
int(5)
val it : int
The program passed the typechecker.
</pre></div>
</div>
</div>
</div>
<div class="section" id="list-and-tuple-constants">
<h2>8.6. List and Tuple Constants<a class="headerlink" href="#list-and-tuple-constants" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="math">
<p><img src="_images/math/01037277a5ff86c8093a064b508bd911414fbf4a.png" alt="[ 6, 5, 4 ] &amp; : int~~list \\
( &quot;hi&quot;, true, 6) &amp; : str * bool * int"/></p>
</div></div></blockquote>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">listcon</span><span class="p">(</span><span class="nv">L</span><span class="p">),</span><span class="nf">listOf</span><span class="p">(</span><span class="nv">T</span><span class="p">))</span> <span class="p">:-</span> <span class="nf">typecheckList</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">L</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">tuple</span><span class="p">(</span><span class="nv">L</span><span class="p">),</span><span class="nf">tuple</span><span class="p">(</span><span class="nv">T</span><span class="p">))</span> <span class="p">:-</span> <span class="nf">typecheckTuple</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">L</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">listOf</span><span class="p">(</span><span class="s s-Atom">int</span><span class="p">)</span>
<span class="nf">tuple</span><span class="p">([</span><span class="s s-Atom">str</span><span class="p">,</span><span class="s s-Atom">bool</span><span class="p">,</span><span class="s s-Atom">int</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>ListCon</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/ffe57165cff61bc5c69052daacc2e1007cb0274c.png" alt="&amp; \forall i~~1\leq i \leq n, n \geq 0\\
&amp; \frac{\varepsilon\vdash e_i:\alpha}{\varepsilon\vdash [e_1,e_2,...,e_n] : \alpha~~list}"/></p>
</div></div></blockquote>
<p><strong>TupleCon</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/a6447f83f4fcc1ffdd43d975dba7a838aa5ac247.png" alt="&amp; \forall ~~1\leq i \leq n, n \geq 0\\
&amp; \frac{\varepsilon\vdash e_i:\alpha_i}{\varepsilon\vdash (e_1,e_2,...,e_n) : \times_{i=1}^n \alpha_i}"/></p>
</div></div></blockquote>
<div class="section" id="example-8-2">
<h3>8.6.1. Example 8.2<a class="headerlink" href="#example-8-2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Typechecking is commencing...
Here is the AST
listcon([int(1),int(2),int(3),int(4)])
val it : int list
The program passed the typechecker.
</pre></div>
</div>
</div>
</div>
<div class="section" id="identifiers">
<h2>8.7. Identifiers<a class="headerlink" href="#identifiers" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">exists</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Name</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">member</span><span class="p">((</span><span class="nv">Name</span><span class="p">,</span><span class="k">_</span><span class="p">),</span><span class="nv">Env</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">find</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Name</span><span class="p">,</span><span class="nv">Type</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">member</span><span class="p">((</span><span class="nv">Name</span><span class="p">,</span><span class="nv">Type</span><span class="p">),</span><span class="nv">Env</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">find</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Name</span><span class="p">,</span><span class="nv">Type</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">writeMsg</span><span class="p">([</span><span class="s s-Atom">&#39;Failed to find &#39;</span><span class="p">,</span>
    <span class="nv">Name</span><span class="p">,</span><span class="s s-Atom">&#39; with type &#39;</span><span class="p">,</span><span class="nv">Type</span><span class="p">,</span>
    <span class="s s-Atom">&#39; in environment : &#39;</span><span class="p">]),</span> <span class="nf">print</span><span class="p">(</span><span class="nv">Env</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">throw</span><span class="p">(</span><span class="nf">typeerror</span><span class="p">(</span><span class="s s-Atom">&#39;unbound identifier&#39;</span><span class="p">)).</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">id</span><span class="p">(</span><span class="nv">Name</span><span class="p">),</span><span class="nv">Type</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">find</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Name</span><span class="p">,</span><span class="nv">Type</span><span class="p">).</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 8.11</strong> Environment Lookup Predicates</p>
</div>
<p><strong>Identifier</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/8291394707c5ffe82d6081d7712890eb9b03c026.png" alt="\frac{}{\varepsilon[id \mapsto \alpha]\vdash id : \alpha}"/></p>
</div></div></blockquote>
<div class="section" id="example-8-3">
<h3>8.7.1. Example 8.3<a class="headerlink" href="#example-8-3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Typechecking is commencing...
Here is the AST
id(println)
val it : &#39;a -&gt; unit
The program passed the typechecker.
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-application">
<h2>8.8. Function Application<a class="headerlink" href="#function-application" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">println</span> <span class="mi">6</span>
</pre></div>
</div>
<p><strong>FunApp</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/30432526ba00f957685d2f9f5b2c32d119a1282c.png" alt="\frac{\varepsilon\vdash e_1 : \alpha\rightarrow\beta, ~~ \alpha'\rightarrow\beta':inst(\alpha\rightarrow\beta),~~ \varepsilon\vdash e_2 : \alpha_{e2}, ~~ \alpha' : inst(\alpha_{e2})}
     {\varepsilon\vdash e_1 e_2 : \beta'}"/></p>
</div></div></blockquote>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nf">instanceOfList</span><span class="p">(</span><span class="nv">Env</span><span class="p">,[],[],</span><span class="nv">Env</span><span class="p">).</span>
<span class="nf">instanceOfList</span><span class="p">(</span><span class="nv">Env</span><span class="p">,[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],[</span><span class="nv">G</span><span class="p">|</span><span class="nv">S</span><span class="p">],</span><span class="nv">NewEnv</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">H</span><span class="p">,</span><span class="nv">G</span><span class="p">,</span><span class="nv">Env1</span><span class="p">),</span> <span class="nf">instanceOfList</span><span class="p">(</span><span class="nv">Env1</span><span class="p">,</span><span class="nv">T</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">NewEnv</span><span class="p">).</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">Env</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">var</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">Env</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">simple</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span> <span class="nf">fn</span><span class="p">(</span><span class="nv">AInst</span><span class="p">,</span><span class="nv">BInst</span><span class="p">),</span><span class="nv">Env2</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">AInst</span><span class="p">,</span><span class="nv">Env1</span><span class="p">),</span> <span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env1</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">BInst</span><span class="p">,</span><span class="nv">Env2</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">listOf</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nf">listOf</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span><span class="nv">NewEnv</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">NewEnv</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">ref</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nf">ref</span><span class="p">(</span><span class="nv">B</span><span class="p">),</span><span class="nv">NewEnv</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">NewEnv</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">tuple</span><span class="p">(</span><span class="nv">L</span><span class="p">),</span><span class="nf">tuple</span><span class="p">(</span><span class="nv">M</span><span class="p">),</span><span class="nv">NewEnv</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">instanceOfList</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">L</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">NewEnv</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">typevar</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">B</span><span class="p">,</span><span class="nv">Env</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">exists</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">),</span> <span class="nf">find</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">typevar</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span><span class="nv">B</span><span class="p">,[(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">)|</span><span class="nv">Env</span><span class="p">])</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">instanceOf</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="k">_</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Type Error: Type &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="k">_</span><span class="p">),</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39; is not an instance of &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="k">_</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">throw</span><span class="p">(</span><span class="nf">typeerror</span><span class="p">(</span><span class="s s-Atom">&#39;type mismatch&#39;</span><span class="p">)),</span> <span class="p">!.</span>
<span class="nf">inst</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">instanceOf</span><span class="p">([],</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="k">_</span><span class="p">).</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 8.12</strong> The Instantiation Operator</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">apply</span><span class="p">(</span><span class="nv">Exp1</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">),</span><span class="nv">ITT</span><span class="p">)</span> <span class="p">:-</span>
        <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp1</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nv">FT</span><span class="p">,</span><span class="nv">TT</span><span class="p">)),</span> <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">Exp2Type</span><span class="p">),</span>
        <span class="nf">inst</span><span class="p">(</span><span class="nv">Exp2Type</span><span class="p">,</span><span class="nv">Exp2TypeInst</span><span class="p">),</span> <span class="nf">catch</span><span class="p">(</span><span class="nf">inst</span><span class="p">(</span><span class="nf">fn</span><span class="p">(</span><span class="nv">FT</span><span class="p">,</span><span class="nv">TT</span><span class="p">),</span> <span class="nf">fn</span><span class="p">(</span><span class="nv">Exp2TypeInst</span><span class="p">,</span><span class="nv">ITT</span><span class="p">)),</span><span class="k">_</span><span class="p">,</span>
        <span class="nf">printApplicationErrorMessage</span><span class="p">(</span><span class="nv">Exp1</span><span class="p">,</span><span class="nf">fn</span><span class="p">(</span><span class="nv">FT</span><span class="p">,</span><span class="nv">TT</span><span class="p">),</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">Exp2Type</span><span class="p">,</span><span class="nv">ITT</span><span class="p">)),</span> <span class="p">!.</span>
</pre></div>
</div>
<p><strong>Fig. 8.13</strong> Function Application Type Inference</p>
</div>
<div class="section" id="instantiation">
<h3>8.8.1. Instantiation<a class="headerlink" href="#instantiation" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="example-8-4">
<h3>8.8.2. Example 8.4<a class="headerlink" href="#example-8-4" title="Permalink to this headline">¶</a></h3>
<div class="math">
<p><img src="_images/math/65028aac425a3d29ff52070dd7702fb24cb4ba23.png" alt="\frac{\varepsilon\vdash println : \alpha\rightarrow unit,~~~
                int\rightarrow unit:inst(\alpha\rightarrow unit),~~~\varepsilon\vdash 6 : int}
     { \varepsilon\vdash println~6 : unit}"/></p>
</div></div>
</div>
<div class="section" id="let-expressions">
<h2>8.9. Let Expressions<a class="headerlink" href="#let-expressions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-8-5">
<h3>8.9.1. Example 8.5<a class="headerlink" href="#example-8-5" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="math">
<p><img src="_images/math/972bf9fd3d58c96e5c6e033062d4500ea64e7f64.png" alt="\varepsilon_1 &amp; = [x\mapsto\alpha\rightarrow\beta,~y\mapsto int,~z\mapsto\alpha\times\beta]\\
\varepsilon_2 &amp; = [u\mapsto\alpha\times\beta\rightarrow\beta,~y\mapsto\ bool]\\
\varepsilon_2\oplus\varepsilon_1 &amp;= [u\mapsto\alpha\times\beta\rightarrow\beta,~y\mapsto\ bool]\oplus[x\mapsto\alpha\rightarrow\beta,~y\mapsto int,~z\mapsto\alpha\times\beta]\\
&amp; = [u\mapsto\alpha\times\beta\rightarrow\beta,~y\mapsto\ bool,x\mapsto\alpha\rightarrow\beta,~y\mapsto int, ~z\mapsto\alpha\times\beta]"/></p>
</div><div class="math">
<p><img src="_images/math/76ac9f2b6f631014d2c64ac0a3275bdf17edf650.png" alt="\varepsilon\vdash dec \Rightarrow \varepsilon_{dec}"/></p>
</div></div></blockquote>
<p><strong>Let</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d18ac2b3eb5a7382e31924554a15eb107c2def16.png" alt="\frac{\varepsilon\vdash dec\Rightarrow\varepsilon_{dec},~~\varepsilon_{dec}\oplus\varepsilon\vdash e_{sequence}:\beta}{\varepsilon\vdash let~dec~in~e_{sequence}~end:\beta}"/></p>
</div></div></blockquote>
<p><strong>ValDec</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/7af0b8ba53513fa9e70fa4d7f8d5054e346ec55e.png" alt="\frac{pat:\alpha\Rightarrow\varepsilon_{pat},~~\varepsilon\vdash e:close(\alpha)}{\varepsilon\vdash val~pat=e\Rightarrow\varepsilon_{pat}}"/></p>
</div></div></blockquote>
<p><strong>ValRecDec</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/c7318c5993fce37d8ba1d3ef23a3c2cb3162694f.png" alt="\frac{[id:\alpha]\oplus\varepsilon\vdash e:\alpha}{\varepsilon\vdash val~rec~id=e\Rightarrow[ id:close(\alpha)]}"/></p>
</div></div></blockquote>
<p><strong>FunDecs</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/986b9daa4504b45c12cac0c1db024eae48bcb225.png" alt="&amp;  \forall i~1 \leq i \leq n, \forall j~1 &lt; j \leq n,~~n \geq 1,\\
&amp; \frac{[id_1\mapsto\alpha_1\rightarrow\beta_1~\{,~id_j\mapsto\alpha_j\rightarrow\beta_j\}]\oplus\varepsilon\vdash id_i~matches_i:\alpha_i\rightarrow\beta_i}{\varepsilon\vdash f\!un~id_1~matches_1~\{and~id_j~matches_j\}\Rightarrow[id_1\mapsto close(\alpha_1\rightarrow\beta_1)~\{,~id_j\mapsto close(\alpha_j\rightarrow\beta_j)\}]}"/></p>
</div></div></blockquote>
</div>
</div>
<div class="section" id="patterns">
<h2>8.10. Patterns<a class="headerlink" href="#patterns" title="Permalink to this headline">¶</a></h2>
<p><strong>IntPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/0b01d094b3c434b9307f986aae7d68c5aba75535.png" alt="\frac{}{integer\_constant:int \Rightarrow [~]}"/></p>
</div></div></blockquote>
<p><strong>BoolPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/bc3830a022221a5fe858565e9d89846425a79c20.png" alt="&amp; \frac{}{true:bool \Rightarrow [~]} \\
&amp; \frac{}{false:bool \Rightarrow [~]}"/></p>
</div></div></blockquote>
<p><strong>StrPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d4a668e9a9665903a97e040b648940f10aab32d1.png" alt="\frac{}{string\_constant:str \Rightarrow [~]}"/></p>
</div></div></blockquote>
<p><strong>NilPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/4592d651e7a59b628ad2102ec4c8204005550712.png" alt="\frac{}{nil:\alpha~list\Rightarrow[~]}"/></p>
</div></div></blockquote>
<p><strong>ConsPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d03ea44f77bc2b562022f95ac286059f67d2a3ac.png" alt="\frac{pat_1:\alpha\Rightarrow  \varepsilon_{pat_1},~~pat_2:\alpha~list\Rightarrow \varepsilon_{pat_2}}
     {pat_1::pat_2 : \alpha~list\Rightarrow \varepsilon_{pat_1}+\varepsilon_{pat_2}}"/></p>
</div></div></blockquote>
<p><strong>TuplePat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/9a58b56a239f3207af94d50e5be4899f3738fd63.png" alt="&amp;  \forall i~1 \leq i \leq n, n \geq 0\\
&amp; \frac{pat_i : \alpha_i \Rightarrow \varepsilon_{pat_i}}
       {(pat_1,pat_2,...,pat_n): \times_{i=1}^{n}\alpha_i\Rightarrow \sum^{n}_{i=1}\varepsilon_{pat_i}}"/></p>
</div></div></blockquote>
<p><strong>ListPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/88c9b891056eb2f61ac6a32935f2efd6bad730b6.png" alt="&amp;  \forall i~1 \leq i \leq n, n \geq 0\\
&amp; \frac{pat_i : \alpha \Rightarrow \varepsilon_{pat_i}}
       {[pat_1,pat_2,...,pat_n]: \alpha~list\Rightarrow \sum^{n}_{i=1}\varepsilon_{pat_i}}"/></p>
</div></div></blockquote>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span>
  <span class="kr">val</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="nv">::</span><span class="n">L</span> <span class="p">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="n">x</span>
<span class="kr">end</span>
</pre></div>
</div>
<p><strong>Fig. 8.14</strong> Pattern Matching</p>
</div>
<p><strong>IdPat</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/99f9656dadc13cc8d7a5a19ef073be7abba29c3a.png" alt="\frac{}{id:\alpha\Rightarrow[id\mapsto\alpha]}"/></p>
</div></div></blockquote>
<div class="section" id="example-8-6">
<h3>8.10.1. Example 8.6<a class="headerlink" href="#example-8-6" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>letdec(
  bindval(infixpat(::,tuplepat([idpat(x),idpat(y)]),idpat(L)),
    listcon([tuple([int(1),int(2)]),tuple([int(3),int(4)])])),
  [apply(id(println),id(x))])
val (x,y)::L : (int * int) list
val it : unit
The program passed the typechecker.
</pre></div>
</div>
<div class="math">
<p><img src="_images/math/f161013f47989eb932b33cdfcdabaf99b19de24c.png" alt="\dfrac{
    (2) \varepsilon\vdash val~(x,y)::L = [(1,2),(3,4)]\Rightarrow\varepsilon_{dec}
    ~~~
(3) \varepsilon_{dec}\oplus\varepsilon\vdash println~x : unit
  }{
    (1)\varepsilon\vdash let~val~(x,y)::L = [(1,2),(3,4)]~in~println~x~end : unit
  }(Let)

  \varepsilon_{dec} =[x\mapsto int, y\mapsto int, L\mapsto int * int~list]"/></p>
</div><p>To prove (2):</p>
<div class="math">
<p><img src="_images/math/a27224e7c8cf69e22eef758eb6d7ed797c621960.png" alt="\dfrac{
   (4) (x,y)::L : int\times int~list\Rightarrow\varepsilon_{dec}
   ~~~
   (5) \varepsilon\vdash [(1,2),(3,4)] : int\times int~list
}{
   (2) \varepsilon\vdash val~(x,y)::L = [(1,2),(3,4)]\Rightarrow\varepsilon_{dec}
}(ValDec)"/></p>
</div><p>To prove (4):</p>
<div class="math">
<p><img src="_images/math/9f10c75eeff0bdaeb3b28e28c883835fd1e39f99.png" alt="\dfrac{
   (6) (x,y) : int \times int \Rightarrow [x\mapsto int, y\mapsto int]
   ~~~
   (7) L : int\times int~list \Rightarrow[L\mapsto int\times int~list]
}{
   (4) (x,y)::L : int\times int~list\Rightarrow\varepsilon_{dec}
}(ConsPat)"/></p>
</div><p>To prove (6):</p>
<div class="math">
<p><img src="_images/math/c8a24233b25e185403d32797914fe559b033c87a.png" alt="\dfrac{
   (8) x : int \Rightarrow[x\mapsto int]
   ~~~
   (9) y : int \Rightarrow[y\mapsto int]
}{
   (6) (x,y) : int \times int \Rightarrow [x\mapsto int, y\mapsto int]
}(TuplePat)"/></p>
</div><p>Premises (7), (8), and (9) are true by virtue of the <em>IdPat</em> inference rule. Considering (5):</p>
<div class="math">
<p><img src="_images/math/8122e2c401b8181e6c2df7aa815f75807d9f7e84.png" alt="\dfrac {
  (10)\varepsilon\vdash (1,2):int\times int
  ~~~
  (11)\varepsilon\vdash (3,4):int\times int
}{
 (5) \varepsilon\vdash [(1,2),(3,4)] : int\times int~list
}(ListCon)"/></p>
</div><p>Considering (10) and a similar argument for (11):</p>
<div class="math">
<p><img src="_images/math/1989620faad92a60cfe3dd215f3e8b928a5c55d2.png" alt="\dfrac{
(12)\varepsilon\vdash 1:int
~~~
(13)\varepsilon\vdash 2:int
  }{
    (10)\varepsilon\vdash (1,2):int\times int
  }(TupleCon)"/></p>
</div><p>Both (12) and (13) are true by the <em>IntCon</em> rule. A similar argument holds for (11). The proof nears completion by proving (3):</p>
<div class="math">
<p><img src="_images/math/283264d3595578dbd984b6853c085d31659d4b17.png" alt="\dfrac{
(14) \varepsilon_{dec}\oplus\varepsilon\vdash println : \alpha\rightarrow unit
~~~
int\rightarrow unit : inst(\alpha\rightarrow unit)
~~~
(15) \varepsilon_{dec}\oplus\varepsilon\vdash x : int
  } {
(3) \varepsilon_{dec}\oplus\varepsilon\vdash println~x : unit
  }(FunApp)"/></p>
</div><p>Both (14) and (15) are true by the <em>Identifier</em> rule concluding the proof of the type correctness of this program.</p>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">6</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">x</span> <span class="n">+</span> <span class="n">y</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</div>
<p><strong>Fig. 8.15</strong> test10.sml</p>
</div>
<div class="exercise docutils container">
<p><strong>Practice 8.1</strong></p>
<p>Prove that the program given in figure 8.13 is correctly typed. The abstract syntax for this program is provided here.</p>
<blockquote>
<div><div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">letdec</span><span class="p">(</span><span class="nf">bindval</span><span class="p">(</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="s s-Atom">&#39;5&#39;</span><span class="p">)),</span>
 <span class="p">[</span><span class="nf">letdec</span><span class="p">(</span><span class="nf">bindval</span><span class="p">(</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">&#39;y&#39;</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="s s-Atom">&#39;6&#39;</span><span class="p">)),</span>
     <span class="p">[</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;println&#39;</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;+&#39;</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;x&#39;</span><span class="p">),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">&#39;y&#39;</span><span class="p">)])))])</span>
 <span class="p">]).</span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference internal" href="#exercise8-1"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
<div class="exercise docutils container">
<p><strong>Practice 8.2</strong></p>
<p>Minimally, what must the type environment contain to correctly type check the program in figure 8.15.</p>
<p><a class="reference internal" href="#exercise8-2"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
</div>
</div>
<div class="section" id="matches">
<h2>8.11. Matches<a class="headerlink" href="#matches" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">fun</span> <span class="nf">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">y</span>
      <span class="p">|</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x*y</span><span class="p">)</span>
    <span class="kr">and</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="kr">end</span>
</pre></div>
</div>
<p><strong>Fig. 8.16</strong> test11.sml</p>
</div>
<p><strong>Matches</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/fd82ded6ece969ae5bb5a6dc681dd2af96bbca81.png" alt="&amp;  \forall i~1 \leq i \leq n, \forall j~1 &lt; j \leq n,~n \geq 1\\
&amp; \frac{\varepsilon\vdash id:\alpha\rightarrow\beta,~~pat_i:\alpha\Rightarrow
   \varepsilon_{pat_i},~~\varepsilon_{pat_i}\oplus\varepsilon\vdash e_i:\beta}
       {\varepsilon\vdash id~pat_1=e_1\{|~id~pat_j=e_j\}:\alpha\rightarrow\beta}"/></p>
</div></div></blockquote>
<p>or</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d1d5bf0d5a5141e64e2945b2fa705985352013c3.png" alt="&amp;  \forall i~1 \leq i \leq n, \forall j~1 &lt; j \leq n,~n \geq 1\\
&amp; \frac{\varepsilon\vdash id:\alpha\rightarrow\beta,~~pat_i:\alpha\Rightarrow
   \varepsilon_{pat_i},~~\varepsilon_{pat_i}\oplus\varepsilon\vdash e_i:\beta}
       {\varepsilon\vdash id~pat_1=&gt;e_1\{|~pat_j=&gt;e_j\}:\alpha\rightarrow\beta}"/></p>
</div></div></blockquote>
<div class="section" id="example-8-7">
<h3>8.11.1. Example 8.7<a class="headerlink" href="#example-8-7" title="Permalink to this headline">¶</a></h3>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">letdec</span><span class="p">(</span>
  <span class="nf">funmatches</span><span class="p">(</span>
    <span class="p">[</span><span class="nf">funmatch</span><span class="p">(</span><span class="s s-Atom">f</span><span class="p">,</span>
       <span class="p">[</span><span class="nf">match</span><span class="p">(</span><span class="nf">tuplepat</span><span class="p">([</span><span class="nf">intpat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)]),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)),</span>
        <span class="nf">match</span><span class="p">(</span><span class="nf">tuplepat</span><span class="p">([</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)]),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">g</span><span class="p">),</span>
           <span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)]))])))]),</span>
     <span class="nf">funmatch</span><span class="p">(</span><span class="s s-Atom">g</span><span class="p">,</span>
       <span class="p">[</span><span class="nf">match</span><span class="p">(</span><span class="nf">tuplepat</span><span class="p">([</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)]),</span>
          <span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">f</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">-</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)])),</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">y</span><span class="p">)])))])]),</span>
  <span class="p">[</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">println</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">f</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">int</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="mi">5</span><span class="p">)])))])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="anonymous-functions">
<h2>8.12. Anonymous Functions<a class="headerlink" href="#anonymous-functions" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Fig. 8.17</strong> Anonymous Function</p>
</div>
<dl class="docutils">
<dt><strong>AnonFun</strong></dt>
<dd><div class="first last math">
<p><img src="_images/math/30124b774db27143be378caa4a2c38e7be81836b.png" alt="\frac{[id\mapsto\alpha\rightarrow\beta]\oplus\varepsilon\vdash id~matches:\alpha\rightarrow\beta}
     {\varepsilon\vdash fn~id~matches:\alpha\rightarrow\beta}"/></p>
</div></dd>
</dl>
<div class="section" id="example-8-8">
<h3>8.12.1. Example 8.8<a class="headerlink" href="#example-8-8" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">func</span><span class="p">(</span><span class="s s-Atom">anon@</span><span class="mi">0</span><span class="p">,[</span><span class="nf">match</span><span class="p">(</span><span class="nf">idpat</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">apply</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">+</span><span class="p">),</span><span class="nf">tuple</span><span class="p">([</span><span class="nf">id</span><span class="p">(</span><span class="s s-Atom">x</span><span class="p">),</span><span class="nf">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)])))])</span>
</pre></div>
</div>
<div class="math">
<p><img src="_images/math/e579aabb41fb40e295ae1ec6324b4425715bbd3c.png" alt="\frac{[anon&#64;0\mapsto int\rightarrow int]\oplus\varepsilon\vdash anon&#64;0~x =&gt; x+1:int\rightarrow int}
     {\varepsilon\vdash fn~anon&#64;0~x =&gt; x+1 :int\rightarrow int}"/></p>
</div></div></blockquote>
<div class="exercise docutils container">
<p><strong>Practice 8.3</strong></p>
<p>Provide a complete proof that the program in figure 8.17 is correctly typed.</p>
<p><a class="reference internal" href="#exercise8-3"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
</div>
</div>
<div class="section" id="sequential-execution">
<h2>8.13. Sequential Execution<a class="headerlink" href="#sequential-execution" title="Permalink to this headline">¶</a></h2>
<p><strong>Sequence</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/8538c0fc73b92a47c8b7971a1438883869febe85.png" alt="&amp;  \forall i~1 \leq i \leq n, \forall j~1 &lt; j \leq n,~n \geq 1\\
&amp;  \frac{\varepsilon\vdash e_i : \alpha_i}
        {\varepsilon\vdash e_1 \{ ; e_j\} : \alpha_n}"/></p>
</div></div></blockquote>
</div>
<div class="section" id="if-then-and-while-do">
<h2>8.14. If-Then and While-Do<a class="headerlink" href="#if-then-and-while-do" title="Permalink to this headline">¶</a></h2>
<p><strong>IfThen</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/81c484c65898e4cea9ac62aa038be6c228a33734.png" alt="\frac{\varepsilon\vdash e_1:bool,~~\varepsilon\vdash e_2:\alpha,~~~\varepsilon\vdash e_3:\alpha}{\varepsilon\vdash i\!f~e_1~then~e_2~else~e_3 : \alpha}"/></p>
</div></div></blockquote>
<p><strong>WhileDo</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/e6d8a5123bb9595d5104cac30694e0212bd995d7.png" alt="\frac{\varepsilon\vdash e_1:bool,~~\varepsilon\vdash e_2:\alpha}{\varepsilon\vdash while~e_1~do~e_2 : \alpha}"/></p>
</div></div></blockquote>
<div class="figboxcenter docutils container">
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">ifthen</span><span class="p">(</span><span class="nv">Exp1</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">Exp3</span><span class="p">),</span> <span class="nv">RT</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp1</span><span class="p">,</span><span class="s s-Atom">bool</span><span class="p">),</span> <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">RT</span><span class="p">),</span> <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp3</span><span class="p">,</span><span class="nv">RT</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">ifthen</span><span class="p">(</span><span class="nv">Exp1</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">Exp3</span><span class="p">),</span> <span class="k">_</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp1</span><span class="p">,</span><span class="s s-Atom">bool</span><span class="p">),</span> <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp2</span><span class="p">,</span><span class="nv">ThenType</span><span class="p">),</span> <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp3</span><span class="p">,</span><span class="nv">ElseType</span><span class="p">),</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Error: Result types of then and else expressions must match.&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Then Expression type is: &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">ThenType</span><span class="p">,</span><span class="k">_</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Else Expression type is: &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">ElseType</span><span class="p">,</span><span class="k">_</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">throw</span><span class="p">(</span><span class="nf">typeerror</span><span class="p">(</span><span class="s s-Atom">&#39;result type mismatch in if-then-else expression&#39;</span><span class="p">)).</span>
<span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nf">ifthen</span><span class="p">(</span><span class="nv">Exp1</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="k">_</span><span class="p">),</span> <span class="k">_</span><span class="p">)</span> <span class="p">:-</span>
    <span class="nf">typecheckExp</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="nv">Exp1</span><span class="p">,</span><span class="nv">Exp1Type</span><span class="p">),</span> <span class="nv">Exp1Type</span> <span class="s s-Atom">\=</span> <span class="s s-Atom">bool</span><span class="p">,</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Error: Condition of if then expression must have bool type.&#39;</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">print</span><span class="p">(</span><span class="s s-Atom">&#39;Condition Expression type was: &#39;</span><span class="p">),</span> <span class="nf">printType</span><span class="p">(</span><span class="nv">Exp1Type</span><span class="p">,</span><span class="k">_</span><span class="p">),</span> <span class="s s-Atom">nl</span><span class="p">,</span>
    <span class="nf">throw</span><span class="p">(</span><span class="nf">typeerror</span><span class="p">(</span><span class="s s-Atom">&#39;type not bool in if-then-else expression condition&#39;</span><span class="p">)).</span>
</pre></div>
</div>
<p><strong>Fig. 8.18</strong> If-Then Prolog Code</p>
</div>
</div>
<div class="section" id="exception-handling">
<h2>8.15. Exception Handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h2>
<p><strong>Handler</strong></p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/ddb33bbf70ea22e09797118946e45c9a51e1d695.png" alt="\frac{\varepsilon\vdash e:\alpha, ~~ [handle&#64;\mapsto~exn\rightarrow\alpha]\oplus\varepsilon\vdash handle&#64;~matches : exn\rightarrow\alpha}
     {\varepsilon\vdash e~handle~matches : \alpha}"/></p>
</div></div></blockquote>
</div>
<div class="section" id="chapter-summary">
<h2>8.16. Chapter Summary<a class="headerlink" href="#chapter-summary" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="review-questions">
<h2>8.17. Review Questions<a class="headerlink" href="#review-questions" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">What appears above and below the line in a type inference rule?</p>
</li>
<li><p class="first">Why don’t infix operators appear in the abstract syntax of programs handled by the type checker?</p>
</li>
<li><p class="first">What does <em>typevar</em> represent in figure 8.6?</p>
</li>
<li><p class="first">What does <em>typeerror</em> represent in figure 8.6?</p>
</li>
<li><p class="first">What does the <em>type</em> of the list [(“hello”,1,true)] look like as a Prolog term?</p>
</li>
<li><p class="first">What is the type environment?</p>
</li>
<li><p class="first">Give an example of the use of the overlay operator.</p>
</li>
<li><p class="first">What pattern(s) are used in this let expression?</p>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="nv">=</span> <span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">true</span><span class="p">)</span> <span class="kr">in</span> <span class="n">println</span> <span class="n">x</span> <span class="kr">end</span>
</pre></div>
</div>
<p>What is the pattern as a Prolog term?</p>
</li>
<li><p class="first">Give an example where the <em>Sequence</em> rule might be used to infer a type.</p>
</li>
<li><p class="first">Give a short example of where the <em>Handler</em> rule might be used to infer a type.</p>
</li>
</ol>
</div>
<div class="section" id="exercises">
<h2>8.18. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">The following program does not compile correctly or typecheck
correctly using the mlcomp compiler and type inference system.
However, it is a valid Standard ML program. Modify both the mlcomp
compiler and type checker to correctly compile and infer its type.
This program is included in the compiler project as test20.sml.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">val</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">l</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="n">s2</span><span class="p">{</span><span class="n">h</span><span class="p">}</span><span class="n">ellop</span><span class="p">{,}</span><span class="mi">1</span><span class="p">,</span><span class="n">true</span><span class="p">)]</span> <span class="ow">in</span> <span class="n">println</span> <span class="n">x</span> <span class="n">end</span>
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Typechecking</span> <span class="ow">is</span> <span class="n">commencing</span><span class="o">...</span>
<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">AST</span>
<span class="n">letdec</span><span class="p">(</span><span class="n">bindval</span><span class="p">(</span><span class="n">listpat</span><span class="p">([</span><span class="n">tuplepat</span><span class="p">([</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">z</span><span class="p">)])]),</span>
       <span class="n">listcon</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nb">bool</span><span class="p">(</span><span class="n">true</span><span class="p">)])])),</span>
       <span class="p">[</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">))])</span>
<span class="n">val</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)]</span> <span class="p">:</span> <span class="p">(</span><span class="nb">str</span> <span class="o">*</span> <span class="nb">int</span> <span class="o">*</span> <span class="nb">bool</span><span class="p">)</span> <span class="nb">list</span>
<span class="n">val</span> <span class="n">it</span> <span class="p">:</span> <span class="n">unit</span>
<span class="n">The</span> <span class="n">program</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">typechecker</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p class="first">Implement the Prolog type predicates to get the following program to
type check successully. This program is test14.sml in the mlcomp
compiler project. This will involve writing type checking predicates
for matching, boolean patterns, integer patterns, and sequential
execution.</p>
<div class="code sml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">fun</span> <span class="n">f</span><span class="p">(</span><span class="n">true</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
      <span class="o">|</span> <span class="n">f</span><span class="p">(</span><span class="n">false</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="ow">and</span> <span class="n">g</span> <span class="mi">0</span> <span class="o">=</span> <span class="p">()</span>
      <span class="o">|</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">true</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="ow">in</span>
       <span class="n">g</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Typechecking</span> <span class="ow">is</span> <span class="n">commencing</span><span class="o">...</span>
<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">AST</span>
<span class="n">letdec</span><span class="p">(</span><span class="n">funmatches</span><span class="p">([</span><span class="n">funmatch</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">tuplepat</span><span class="p">([</span><span class="n">boolpat</span><span class="p">(</span><span class="n">true</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">)]),</span>
       <span class="n">expsequence</span><span class="p">([</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="o">-</span><span class="p">),</span>
       <span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)])))])),</span><span class="n">match</span><span class="p">(</span><span class="n">tuplepat</span><span class="p">([</span><span class="n">boolpat</span><span class="p">(</span><span class="n">false</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">)]),</span>
       <span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="o">-</span><span class="p">),</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)]))))]),</span><span class="n">funmatch</span><span class="p">(</span><span class="n">g</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
       <span class="nb">tuple</span><span class="p">([])),</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">bool</span><span class="p">(</span><span class="n">true</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)])))])]),</span>
       <span class="p">[</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">))])</span>
<span class="n">val</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fn</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">*</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">unit</span>
<span class="n">val</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fn</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">unit</span>
<span class="n">val</span> <span class="n">it</span> <span class="p">:</span> <span class="n">unit</span>
<span class="n">The</span> <span class="n">program</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">typechecker</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p class="first">Implement enough of the type checker to get test12.sml to type check
correctly. This will mean writing the <em>WhileDo</em> inference rule as a
Prolog predicate, implementing the <em>Match</em> rule’s predicate called
<em>typecheckMatch</em>, and the type inference predicate for sequential
execution named <em>typecheckSequence</em> as defined in the <em>Sequence</em>
rule. The code for test12.sml is given here for reference.</p>
<div class="code sml highlight-default notranslate"><div class="highlight"><pre><span></span>let val zero = 0
    fun fib n =
    let val i = ref zero
        val current = ref 0
        val next = ref 1
        val tmp = ref 0
    in
      while !i &lt; n do (
        tmp := !next + !current;
        current := !next;
        next := !tmp;
        i := !i + 1
      );
      !current
    end
    val x = Int.fromString(input(l+s+s2{&quot;lease enter an integer: &quot;))
    val r = fib(x)
in
  print l+s+s2{F}ib(p{;}
  print x;
  print l+s+s2{)} is p{;}
  println r
end
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Typechecking is commencing...
Here is the AST
letdec(bindval(idpat(zero),int(0)),[letdec(funmatches([funmatch(fib,
   [match(idpat(n),letdec(bindval(idpat(i),apply(id(ref),id(zero))),
   [letdec(bindval(idpat(current),apply(id(ref),int(0))),
   [letdec(bindval(idpat(next),apply(id(ref),int(1))),
   [letdec(bindval(idpat(tmp),apply(id(ref),int(0))),
   [whiledo(apply(id(&lt;),tuple([apply(id(!),id(i)),id(n)])),
   expsequence([apply(id(:=),tuple([id(tmp),apply(id(+),tuple([apply(id(!),id(next)),
   apply(id(!),id(current))]))])),apply(id(:=),tuple([id(current),apply(id(!),
   id(next))])),apply(id(:=),tuple([id(next),apply(id(!),id(tmp))])),apply(id(:=),
   tuple([id(i),apply(id(+),tuple([apply(id(!),id(i)),int(1)]))]))])),apply(id(!),
   id(current))])])])]))])]),[letdec(bindval(idpat(x),apply(id(Int.fromString),
   apply(id(input),str(&quot;Please enter an integer: &quot;)))),
   [letdec(bindval(idpat(r),apply(id(fib),id(x))),[apply(id(print),str(&quot;Fib(&quot;)),
   apply(id(print),id(x)),apply(id(print),str(&quot;) is &quot;)),apply(id(println),id(r))])])])])
val zero : int
val i : int ref
val current : int ref
val next : int ref
val tmp : int ref
val fib = fn : int -&gt; int
val x : int
val r : int
val it : unit
The program passed the typechecker.
</pre></div>
</div>
</li>
<li><p class="first">Add support to the type checker to correctly infer the types of
<em>case</em> expressions in Small. The following program should type check
correctly once this project is completed. This test is in test15.sml
in the mlcomp compiler project. This will involve writing code to
correctly type check matches according to the <em>Match</em> rule. If case
statments are not yet implemented in the compiler, support must be
added to the compiler to parse <em>case</em> expressions, build an AST for
them, and write their AST to the <em>a.term</em> file.</p>
<div class="code sml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="ow">in</span>
  <span class="n">println</span>
    <span class="p">(</span><span class="n">case</span> <span class="n">x</span> <span class="n">of</span>
      <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
    <span class="o">|</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s2">&quot;how&quot;</span>
    <span class="o">|</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s2">&quot;are&quot;</span>
    <span class="o">|</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="s2">&quot;you&quot;</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Typechecking</span> <span class="ow">is</span> <span class="n">commencing</span><span class="o">...</span>
<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">AST</span>
<span class="n">letdec</span><span class="p">(</span><span class="n">bindval</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">6</span><span class="p">)),[</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span><span class="n">caseof</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
       <span class="p">[</span><span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)),</span><span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;how&quot;</span><span class="p">)),</span>
       <span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;are&quot;</span><span class="p">)),</span><span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="s2">&quot;you&quot;</span><span class="p">))]))])</span>
<span class="n">val</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">int</span>
<span class="n">val</span> <span class="n">it</span> <span class="p">:</span> <span class="n">unit</span>
<span class="n">The</span> <span class="n">program</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">typechecker</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p class="first">Add support to the type checker to correctly infer the types for
test7.sml. The code is provided below for reference. Support will
need to be added to infer the types of anonymous functions defined in
the rule <em>AnonFun</em>, matching defined in the rule <em>Matches</em>, and the
<em>ConsPat</em> rule.</p>
<div class="code sml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">fun</span> <span class="n">append</span> <span class="n">nil</span> <span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
      <span class="o">|</span> <span class="n">append</span> <span class="p">(</span><span class="n">h</span><span class="p">::</span><span class="n">t</span><span class="p">)</span> <span class="n">L</span> <span class="o">=</span> <span class="n">h</span> <span class="p">::</span> <span class="p">(</span><span class="n">append</span> <span class="n">t</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">fun</span> <span class="n">appendOne</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span> <span class="n">nil</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">fn</span> <span class="n">L</span> <span class="o">=&gt;</span> <span class="n">L</span><span class="p">)</span>
                        <span class="o">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">fn</span> <span class="n">L</span> <span class="o">=&gt;</span> <span class="n">h</span> <span class="p">::</span> <span class="p">(</span><span class="n">appendOne</span> <span class="n">t</span> <span class="n">L</span><span class="p">)))</span> <span class="n">x</span>
<span class="ow">in</span>
  <span class="n">println</span><span class="p">(</span><span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
  <span class="n">println</span><span class="p">(</span><span class="n">appendOne</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">end</span>
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Typechecking</span> <span class="ow">is</span> <span class="n">commencing</span><span class="o">...</span>
<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">AST</span>
<span class="n">letdec</span><span class="p">(</span><span class="n">funmatches</span><span class="p">([</span><span class="n">funmatch</span><span class="p">(</span><span class="n">append</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">v0</span><span class="p">),</span><span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@3</span><span class="p">,</span>
<span class="p">[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@2</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">tuplepat</span><span class="p">([</span><span class="n">idpat</span><span class="p">(</span><span class="n">nil</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">L</span><span class="p">)]),</span><span class="nb">id</span><span class="p">(</span><span class="n">L</span><span class="p">)),</span>
<span class="n">match</span><span class="p">(</span><span class="n">tuplepat</span><span class="p">([</span><span class="n">infixpat</span><span class="p">(::,</span><span class="n">idpat</span><span class="p">(</span><span class="n">h</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span><span class="n">idpat</span><span class="p">(</span><span class="n">L</span><span class="p">)]),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(::),</span>
<span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">h</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">append</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span><span class="nb">id</span><span class="p">(</span><span class="n">L</span><span class="p">))])))]),</span>
<span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">v0</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">v1</span><span class="p">)])))]))])]),[</span><span class="n">letdec</span><span class="p">(</span><span class="n">funmatches</span><span class="p">([</span><span class="n">funmatch</span><span class="p">(</span><span class="n">appendOne</span><span class="p">,</span>
<span class="p">[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@6</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">nil</span><span class="p">),</span><span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@4</span><span class="p">,</span>
<span class="p">[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">L</span><span class="p">))])),</span><span class="n">match</span><span class="p">(</span><span class="n">infixpat</span><span class="p">(::,</span><span class="n">idpat</span><span class="p">(</span><span class="n">h</span><span class="p">),</span><span class="n">idpat</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@5</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(::),</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">h</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">appendOne</span><span class="p">),</span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="nb">id</span><span class="p">(</span><span class="n">L</span><span class="p">))])))]))]),</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)))])]),[</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">append</span><span class="p">),</span>
<span class="n">listcon</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)])),</span><span class="n">listcon</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">)]))),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span>
<span class="n">apply</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">appendOne</span><span class="p">),</span><span class="n">listcon</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)])),</span><span class="n">listcon</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">)])))])])</span>
<span class="n">val</span> <span class="n">append</span> <span class="o">=</span> <span class="n">fn</span> <span class="p">:</span> <span class="s1">&#39;a list -&gt; &#39;</span><span class="n">a</span> <span class="nb">list</span> <span class="o">-&gt;</span> <span class="s1">&#39;a list</span>
<span class="n">val</span> <span class="n">appendOne</span> <span class="o">=</span> <span class="n">fn</span> <span class="p">:</span> <span class="s1">&#39;a list -&gt; &#39;</span><span class="n">a</span> <span class="nb">list</span> <span class="o">-&gt;</span> <span class="s1">&#39;a list</span>
<span class="n">val</span> <span class="n">it</span> <span class="p">:</span> <span class="n">unit</span>
<span class="n">The</span> <span class="n">program</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">typechecker</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p class="first">Add support for type inference for recursive bindings. The following
program, saved as test19.sml in the Small compiler project, is a
valid program with a recursive binding. It will type check correctly
if the <em>ValRecDec</em> type inference rule is implemented. Write the code
to get this program to pass the type checker as a valid program.</p>
<div class="code sml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">val</span> <span class="n">rec</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">1</span>
                  <span class="o">|</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="ow">in</span>
   <span class="n">println</span><span class="p">(</span><span class="n">f</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
</div>
<p>Output from the type checker should appear as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Typechecking</span> <span class="ow">is</span> <span class="n">commencing</span><span class="o">...</span>
    <span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">AST</span>
    <span class="n">letdec</span><span class="p">(</span><span class="n">bindvalrec</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">func</span><span class="p">(</span><span class="n">anon</span><span class="nd">@0</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">intpat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
       <span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="o">-</span><span class="p">),</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)])))])))])),</span>
       <span class="p">[</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">println</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="mi">5</span><span class="p">)))])</span>
    <span class="n">val</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fn</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
    <span class="n">val</span> <span class="n">it</span> <span class="p">:</span> <span class="n">unit</span>
    <span class="n">The</span> <span class="n">program</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">typechecker</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p class="first">Currently the type checker allows duplicate identifiers in compound
patterns like listPat and tuplePat. Standard ML does not allow
duplicate identifiers in patterns. The type checker uses the <em>append</em>
predicate to combine pattern binding environments. This is not good
enough. Find the locations in the type checker where pattern
environments are incorrectly appended and rewrite this code to
enforce that all identifiers within a pattern must be unique. If not,
you should print an error message like <em>“Error: duplicate variable in
pattern(s): x”</em> to indicate the problem and typechecking should end
with an error.</p>
</li>
<li><p class="first">Currently, the abstract syntax and parser of <em>Small</em> includes support
for the wildcard pattern in pattern matching, but the type checker
does not support it. Add support for wildcard patterns, write a test
program, and test the compiler and type checker. Be sure to write a
type inference rule for wildcard patterns first.</p>
</li>
<li><p class="first">Currently, the abstract syntax and parser of <em>Small</em> includes support
for the <em>as</em> pattern in pattern matching, but the type checker does
not support it. Add support for <em>as</em> patterns, write a test program,
and test the compiler and type checker. The <em>as</em> pattern comes up
when you write a pattern like <em>L as h::t</em> which assigns <em>L</em> as a
pattern that represents the same value as the compound pattern of
<em>h::t</em>. Be sure to write a type inference rule for <em>as</em> patterns
first.</p>
</li>
</ol>
</div>
<div class="section" id="solutions-to-practice-problems">
<h2>8.19. Solutions to Practice Problems<a class="headerlink" href="#solutions-to-practice-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="solution-to-practice-problem-8-1">
<span id="exercise8-1"></span><h3>8.19.1. Solution to Practice Problem 8.1<a class="headerlink" href="#solution-to-practice-problem-8-1" title="Permalink to this headline">¶</a></h3>
<p>The complexity of append is O(n) in the length of the first list.</p>
</div>
<div class="section" id="solution-to-practice-problem-8-2">
<span id="exercise8-2"></span><h3>8.19.2. Solution to Practice Problem 8.2<a class="headerlink" href="#solution-to-practice-problem-8-2" title="Permalink to this headline">¶</a></h3>
<p>Minimally the environment must contain <em>println</em> bound to a function
type of <img class="math" src="_images/math/588846c62b8d9558d4dfffed59a9d63253599f42.png" alt="\alpha\rightarrow unit"/> and the <em>+</em> function bound to a
function type of <img class="math" src="_images/math/8acb5bb66dfca2ab2101fc319c4b38c2c39e7392.png" alt="int\times int \rightarrow int"/>.</p>
</div>
<div class="section" id="solution-to-practice-problem-8-3">
<span id="exercise8-3"></span><h3>8.19.3. Solution to Practice Problem 8.3<a class="headerlink" href="#solution-to-practice-problem-8-3" title="Permalink to this headline">¶</a></h3>
<p>The <em>AnonFun</em> rule is applied first which requires the <em>Matches</em> rule be
applied. The <em>Matches</em> rule requires the use of the <em>IdPat</em> rule and the
<em>FunApp</em> rule. Finally, the <em>IntCon</em> rule is needed to complete the
proof.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="prolog.html" title="7. Prolog"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Foundations of Programming Languages Second Edition</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Kent D. Lee.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>