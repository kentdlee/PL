

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>6. Compiling Standard ML &#8212; Foundations of Programming Languages Second Edition</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Prolog" href="prolog.html" />
    <link rel="prev" title="5. Standard ML" href="functional.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="prolog.html" title="7. Prolog"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functional.html" title="5. Standard ML"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Foundations of Programming Languages Second Edition</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. Compiling Standard ML</a><ul>
<li><a class="reference internal" href="#ml-lex">6.1. ML-lex</a><ul>
<li><a class="reference internal" href="#example-6-1">6.1.1. Example 6.1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-small-ast-definition">6.2. The Small AST Definition</a></li>
<li><a class="reference internal" href="#using-ml-yacc">6.3. Using ML-yacc</a><ul>
<li><a class="reference internal" href="#example-6-3">6.3.1. Example 6.3</a></li>
<li><a class="reference internal" href="#example-6-4">6.3.2. Example 6.4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compiling-and-running-the-compiler">6.4. Compiling and Running the Compiler</a><ul>
<li><a class="reference internal" href="#example-6-5">6.4.1. Example 6.5</a></li>
<li><a class="reference internal" href="#example-6-6">6.4.2. Example 6.6</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-calls">6.5. Function Calls</a></li>
<li><a class="reference internal" href="#let-expressions">6.6. Let Expressions</a></li>
<li><a class="reference internal" href="#unary-negation">6.7. Unary Negation</a></li>
<li><a class="reference internal" href="#if-then-else-expressions">6.8. If-Then-Else Expressions</a></li>
<li><a class="reference internal" href="#short-circuit-logic">6.9. Short-Circuit Logic</a></li>
<li><a class="reference internal" href="#defining-functions">6.10. Defining Functions</a><ul>
<li><a class="reference internal" href="#curried-functions">6.10.1. Curried Functions</a></li>
<li><a class="reference internal" href="#mutually-recursive-functions">6.10.2. Mutually Recursive Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-variables">6.11. Reference Variables</a></li>
<li><a class="reference internal" href="#chapter-summary">6.12. Chapter Summary</a></li>
<li><a class="reference internal" href="#review-questions">6.13. Review Questions</a></li>
<li><a class="reference internal" href="#exercises">6.14. Exercises</a></li>
<li><a class="reference internal" href="#solutions-to-practice-problems">6.15. Solutions to Practice Problems</a><ul>
<li><a class="reference internal" href="#solution-to-practice-problem-6-1">6.15.1. Solution to Practice Problem 6.1</a></li>
<li><a class="reference internal" href="#solution-to-practice-problem-6-2">6.15.2. Solution to Practice Problem 6.2</a></li>
<li><a class="reference internal" href="#solution-to-practice-problem-6-3">6.15.3. Solution to Practice Problem 6.3</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="functional.html"
                        title="previous chapter">5. Standard ML</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="prolog.html"
                        title="next chapter">7. Prolog</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/usingsml.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="compiling-standard-ml">
<span id="usingsml"></span><h1>6. Compiling Standard ML<a class="headerlink" href="#compiling-standard-ml" title="Permalink to this headline">¶</a></h1>
<div class="figboxcenter docutils container">
<div class="figure" id="id1">
<img alt="_images/mlcalccomp.png" src="_images/mlcalccomp.png" />
<p class="caption"><span class="caption-text">Structure of MLComp</span></p>
</div>
</div>
<div class="section" id="ml-lex">
<h2>6.1. ML-lex<a class="headerlink" href="#ml-lex" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">User</span> <span class="n">declarations</span>
<span class="n">%%</span>
<span class="n">ML-lex</span> <span class="n">definitions</span>
<span class="n">%%</span>
<span class="n">Token</span> <span class="n">Rules</span>
</pre></div>
</div>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">reg_exp</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">return_value</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="example-6-1">
<h3>6.1.1. Example 6.1<a class="headerlink" href="#example-6-1" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="figbox docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span>(* mlcomp.lex -- lexer spec *)
type pos = int
type svalue = Tokens.svalue
type (&#39;a, &#39;b) token = (&#39;a, &#39;b) Tokens.token
type lexresult = (svalue, pos) token
val pos = ref 1
val error = fn x =&gt; TextIO.output(TextIO.stdErr, x ^ &quot;\n&quot;)
val eof = fn () =&gt; Tokens.EOF(!pos, !pos)
fun countnewlines s =
    let val lst = explode s
        fun count (c:char) nil = 0
          | count c (h::t) =
            let val tcount = count c t
            in
              if c = h then 1+tcount else tcount
            end
    in
      pos:= (!pos) + (count #&quot;\n&quot; lst)
    end
%%
%header (functor mlcompLexFun(structure Tokens : mlcomp_TOKENS));
alpha=[A-Za-z];
alphanumeric=[A-Za-z0-9_\.];
digit=[0-9];
ws=[\ \t];
dquote=[\&quot;];
squote=[\&#39;];
anycharbutquote=[^&quot;];
anychar=[.];
pound=[\#];
tilde=[\~];
period=[\.];
%%
\(\*([^*]|[\r\n]|(\*+([^*\)]|[\r\n])))*\*+\) =&gt; (countnewlines yytext; lex());
\n  =&gt; (pos := (!pos) + 1; lex());
{ws}+  =&gt; (lex());
&quot;+&quot;  =&gt; (Tokens.Plus(!pos,!pos));
&quot;*&quot;  =&gt; (Tokens.Times(!pos,!pos));
&quot;-&quot;  =&gt; (Tokens.Minus(!pos,!pos));
&quot;@&quot;  =&gt; (Tokens.Append(!pos,!pos));
&quot;=&quot; =&gt; (Tokens.Equals(!pos,!pos));
&quot;(&quot;  =&gt; (Tokens.LParen(!pos,!pos));
&quot;)&quot;  =&gt; (Tokens.RParen(!pos,!pos));
&quot;[&quot; =&gt; (Tokens.LBracket(!pos,!pos));
&quot;]&quot; =&gt; (Tokens.RBracket(!pos,!pos));
&quot;::&quot; =&gt; (Tokens.ListCons(!pos,!pos));
&quot;,&quot; =&gt; (Tokens.Comma(!pos,!pos));
&quot;;&quot; =&gt; (Tokens.Semicolon(!pos,!pos));
&quot;_&quot; =&gt; (Tokens.Underscore(!pos,!pos));
&quot;=&gt;&quot; =&gt; (Tokens.Arrow(!pos,!pos));
&quot;|&quot; =&gt; (Tokens.VerticalBar(!pos,!pos));
&quot;&gt;&quot; =&gt; (Tokens.Greater(!pos,!pos));
&quot;&lt;&quot; =&gt; (Tokens.Less(!pos,!pos));
&quot;&gt;=&quot; =&gt; (Tokens.GreaterEqual(!pos,!pos));
&quot;&lt;=&quot; =&gt; (Tokens.LessEqual(!pos,!pos));
&quot;&lt;&gt;&quot; =&gt; (Tokens.NotEqual(!pos,!pos));
&quot;!&quot; =&gt; (Tokens.Exclaim(!pos,!pos));
&quot;:=&quot; =&gt; (Tokens.SetEqual(!pos,!pos));


{tilde}?{digit}+  =&gt; (Tokens.Int(yytext,!pos,!pos));
{pound}{dquote}{anychar}{dquote} =&gt; (Tokens.Char(yytext,!pos,!pos));
{dquote}{anycharbutquote}*{dquote} =&gt; (Tokens.String(yytext,!pos,!pos));
{alpha}{alphanumeric}*=&gt;
   (let val tok = String.implode (List.map (Char.toLower)
             (String.explode yytext))
    in
      if      tok=&quot;let&quot; then Tokens.Let(!pos,!pos)
      else if tok=&quot;val&quot; then Tokens.Val(!pos,!pos)
      else if tok=&quot;in&quot; then Tokens.In(!pos,!pos)
      else if tok=&quot;end&quot; then Tokens.End(!pos,!pos)
      else if tok=&quot;if&quot; then Tokens.If(!pos,!pos)
      else if tok=&quot;then&quot; then Tokens.Then(!pos,!pos)
      else if tok=&quot;else&quot; then Tokens.Else(!pos,!pos)
      else if tok=&quot;div&quot; then Tokens.Div(!pos,!pos)
      else if tok=&quot;mod&quot; then Tokens.Mod(!pos,!pos)
      else if tok=&quot;fn&quot; then Tokens.Fn(!pos,!pos)
      else if tok=&quot;while&quot; then Tokens.While(!pos,!pos)
      else if tok=&quot;do&quot; then Tokens.Do(!pos,!pos)
      else if tok=&quot;and&quot; then Tokens.And(!pos,!pos)
      else if tok=&quot;rec&quot; then Tokens.Rec(!pos,!pos)
      else if tok=&quot;fun&quot; then Tokens.Fun(!pos,!pos)
      else if tok=&quot;as&quot; then Tokens.As(!pos,!pos)
      else if tok=&quot;handle&quot; then Tokens.Handle(!pos,!pos)
      else if tok=&quot;raise&quot; then Tokens.Raise(!pos,!pos)
      else if tok=&quot;true&quot; then Tokens.True(!pos,!pos)
      else if tok=&quot;false&quot; then Tokens.False(!pos,!pos)
      else Tokens.Id(yytext,!pos,!pos)
    end);
.  =&gt; (error (&quot;error: bad token &quot;^yytext); lex())
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.2, 6.3, 6.4</strong> mlcomp.lex</p>
</div>
</div></blockquote>
<div class="exercise docutils container">
<p><strong>Practice 6.1</strong></p>
<p>Given the ML-lex specification in example~, what more would have to be added to allow expressions like this to be correctly tokenized by the scanner? What new tokens would have to be recognized? How would you modify the specification to accept these tokens?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case x of
   1 =&gt; &quot;hello&quot;
 | 2 =&gt; &quot;how&quot;
 | 3 =&gt; &quot;are&quot;
 | 4 =&gt; &quot;you&quot;
</pre></div>
</div>
<p><a class="reference internal" href="#exercise6-1"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
</div>
</div>
<div class="section" id="the-small-ast-definition">
<h2>6.2. The Small AST Definition<a class="headerlink" href="#the-small-ast-definition" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">structure</span> <span class="nn">MLAS</span> <span class="p">=</span>
<span class="kr">struct</span>

<span class="kr">datatype</span>
  <span class="kt">exp</span> <span class="p">=</span> <span class="nc">int</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">ch</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">str</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">boolval</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">id</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">listcon</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">tuplecon</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">apply</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">infixexp</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">expsequence</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">letdec</span> <span class="kr">of</span> <span class="n">dec</span> <span class="n">*</span> <span class="p">(</span><span class="n">exp</span> <span class="n">list</span><span class="p">)</span>
      <span class="p">|</span> <span class="nc">raisexp</span> <span class="kr">of</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">handlexp</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">ifthen</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">whiledo</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">func</span> <span class="kr">of</span> <span class="n">int</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
<span class="kr">and</span>
  <span class="kt">match</span> <span class="p">=</span> <span class="nc">match</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
<span class="kr">and</span>
  <span class="kt">pat</span> <span class="p">=</span> <span class="nc">intpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">chpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">strpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">boolpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">idpat</span> <span class="kr">of</span> <span class="n">string</span>
      <span class="p">|</span> <span class="nc">wildcardpat</span>
      <span class="p">|</span> <span class="nc">infixpat</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">pat</span>
      <span class="p">|</span> <span class="nc">tuplepat</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">listpat</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">aspat</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">pat</span>
<span class="kr">and</span>
  <span class="kt">dec</span> <span class="p">=</span> <span class="nc">bindval</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">bindvalrec</span> <span class="kr">of</span> <span class="n">pat</span> <span class="n">*</span> <span class="n">exp</span>
      <span class="p">|</span> <span class="nc">funmatch</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
      <span class="p">|</span> <span class="nc">funmatches</span> <span class="kr">of</span>
             <span class="p">(</span><span class="n">string</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span><span class="p">)</span> <span class="n">list</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.5</strong> mlast.sml</p>
</div>
<div class="exercise docutils container">
<p><strong>Practice 6.2</strong></p>
<p>How would you modify the abstract syntax so expressions like the one below could be represented?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case x of
   1 =&gt; &quot;hello&quot;
 | 2 =&gt; &quot;how&quot;
 | 3 =&gt; &quot;are&quot;
 | 4 =&gt; &quot;you&quot;
</pre></div>
</div>
<p><a class="reference internal" href="#exercise6-2"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
</div>
<div class="section" id="using-ml-yacc">
<h2>6.3. Using ML-yacc<a class="headerlink" href="#using-ml-yacc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>User declarations
%%
ML-yacc definitions
%%
Rules
</pre></div>
</div>
<div class="section" id="example-6-3">
<h3>6.3.1. Example 6.3<a class="headerlink" href="#example-6-3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="figbox docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142</pre></div></td><td class="code"><div class="highlight"><pre><span></span>open MLAS;
val idnum = ref 0
fun nextIdNum() =
  let val x = !idnum
  in
    idnum := !idnum + 1;
    x
  end
exception emptyDecList;
exception argumentMismatch;
fun uncurryIt nil = raise emptyDecList
  | uncurryIt (L as ((name,patList,exp)::t)) =
    let fun len nil = raise argumentMismatch
          | len [(n,p,e)] = length(p)
          | len ((n,p,e)::t) =
            let val size = length(p)
            in
              if size = len t then size else
                (TextIO.output(TextIO.stdOut,
                &quot;Syntax Error: Number of arguments does not match in function &quot;
                ^name^&quot;\n&quot;);
                 raise argumentMismatch)
            end
        val tupleList = List.map (fn x =&gt; &quot;v&quot;^Int.toString(nextIdNum())) patList
     in
       len(L); (* just check the parameter list sizes so all patterns have same length *)
       (name,[match(idpat(hd(tupleList)),
                 List.foldr (fn (x,y) =&gt; func(nextIdNum(),[match(idpat(x), y)]))
                    (apply (func(nextIdNum(),
                            List.map (fn (n,p,e) =&gt; match(tuplepat(p),e)) L),
                            tuplecon(List.map (fn x =&gt; id(x)) tupleList)))
                        (tl tupleList))])
     end
fun makeMatchList (nil) = raise emptyDecList
  | makeMatchList (L as (name,pat,exp)::t) =
    (name, List.map (fn (n,p,e) =&gt;
               (if name &lt;&gt; n then (
                   TextIO.output(TextIO.stdOut,
                   &quot;Syntax Error: Function definition with different names &quot;
                   ^name^&quot; and &quot;^n^&quot; not allowed.\n&quot;);
                   raise argumentMismatch)
                else match(p,e))) L)
%%
%name mlcomp (* mlcomp becomes a prefix in functions *)
%verbose
%eop EOF
%pos int
%nodefault
%pure (* no side-effects in actions *)
%term EOF | LParen | RParen | Plus | Minus | Times | Div | Mod | Greater | Less
    | GreaterEqual | LessEqual | NotEqual | Append | ListCons | Negate | Comma
    | Semicolon | Underscore | Arrow | Equals | VerticalBar | LBracket | RBracket
    | Fun | As | Let | Val | In | End | If | Then | Else | Fn | While | Do | Handle
    | Raise | And | Rec | String of string | Char of string | Int of string | True
    | False | Id of string | SetEqual | Exclaim
%nonterm Prog of exp | Exp of exp | Expressions of exp list | ExpSequence of exp list
       | MatchExp of match list | Pat of pat | Patterns of pat list
       | PatternSeq of pat list | Dec of dec | ValBind of dec
       | FunBind of (string * match list) list | FunMatch of (string * pat * exp) list
       | Con of exp | FuncExp of exp | DecSeq of dec list
       | CurriedFun of (string * pat list * exp) list
%right SetEqual
%left Plus Minus Append Equals NotEqual
%left Times Div Mod Greater Less GreaterEqual LessEqual
%right ListCons
%right Exclaim
%%
Prog : Exp EOF                                             (Exp)
Exp : Con                                                  (Con)
    | Id                                                   (id(Id))
    | FuncExp Exp                                          (apply(FuncExp,Exp))
    | Exclaim Exp                                          (apply(id(&quot;!&quot;),Exp))
    | Id SetEqual FuncExp                                  (infixexp(&quot;:=&quot;,id(Id),FuncExp))
    | Exp Plus Exp                                         (infixexp(&quot;+&quot;,Exp1,Exp2))
    | Exp Minus Exp                                        (infixexp(&quot;-&quot;,Exp1,Exp2))
    | Exp Times Exp                                        (infixexp(&quot;*&quot;,Exp1,Exp2))
    | Exp Div Exp                                          (infixexp(&quot;div&quot;,Exp1,Exp2))
    | Exp Mod Exp                                          (infixexp(&quot;mod&quot;,Exp1,Exp2))
    | Exp Greater Exp                                      (infixexp(&quot;&gt;&quot;,Exp1,Exp2))
    | Exp GreaterEqual Exp                                 (infixexp(&quot;&gt;=&quot;,Exp1,Exp2))
    | Exp Less Exp                                         (infixexp(&quot;&lt;&quot;,Exp1,Exp2))
    | Exp LessEqual Exp                                    (infixexp(&quot;&lt;=&quot;,Exp1,Exp2))
    | Exp Equals Exp                                       (infixexp(&quot;=&quot;,Exp1,Exp2))
    | Exp NotEqual Exp                                     (infixexp(&quot;&lt;&gt;&quot;,Exp1,Exp2))
    | Exp Append Exp                                       (infixexp(&quot;@&quot;,Exp1,Exp2))
    | Exp ListCons Exp                                     (infixexp(&quot;::&quot;,Exp1,Exp2))
    | LParen Exp RParen                                    (Exp)
    | LParen Expressions RParen                            (tuplecon(Expressions))
    | LParen ExpSequence RParen                            (expsequence(ExpSequence))
    | LBracket Expressions RBracket                        (listcon(Expressions))
    | LBracket RBracket                                    (id(&quot;nil&quot;))
    | Let DecSeq In ExpSequence End
                (List.hd (List.foldr (fn (x,y) =&gt; [letdec(x,y)]) ExpSequence DecSeq))
    | Raise Exp                                            (raisexp(Exp))
    | Exp Handle MatchExp                                  (handlexp(Exp,MatchExp))
    | If Exp Then Exp Else Exp                             (ifthen(Exp1,Exp2,Exp3))
    | While Exp Do Exp                                     (whiledo(Exp1,Exp2))
    | Fn MatchExp                                          (func(nextIdNum(),MatchExp))
FuncExp : Exp                                              (Exp)
Expressions : Exp                                          ([Exp])
            | Exp Comma Expressions                        (Exp::Expressions)
ExpSequence : Exp                                          ([Exp])
            | Exp Semicolon ExpSequence                    (Exp::ExpSequence)
MatchExp : Pat Arrow Exp                                   ([match(Pat,Exp)])
         | Pat Arrow Exp VerticalBar MatchExp              (match(Pat,Exp)::MatchExp)
Pat : Int                                                  (intpat(Int))
    | Char                                                 (chpat(Char))
    | String                                               (strpat(String))
    | True                                                 (boolpat(&quot;true&quot;))
    | False                                                (boolpat(&quot;false&quot;))
    | Underscore                                           (wildcardpat)
    | Id                                                   (idpat(Id))
    | Pat ListCons Pat                                     (infixpat(&quot;::&quot;,Pat1,Pat2))
    | LParen Pat RParen                                    (Pat)
    | LParen Patterns RParen                               (tuplepat(Patterns))
    | LBracket Patterns RBracket                           (listpat(Patterns))
    | LBracket RBracket                                    (idpat(&quot;nil&quot;))
    | Id As Pat                                            (aspat(Id,Pat))
Patterns : Pat                                             ([Pat])
         | Pat Comma Patterns                              (Pat::Patterns)
PatternSeq : Pat                                           ([Pat])
           | Pat PatternSeq                                (Pat::PatternSeq)
Dec : Val ValBind                                          (ValBind)
    | Fun FunBind                                          (funmatches(FunBind))
DecSeq : Dec                                               ([Dec])
       | Dec DecSeq                                        (Dec::DecSeq)
ValBind : Pat Equals Exp                                   (bindval(Pat,Exp))
        | Rec Id Equals Exp                                (bindvalrec(idpat(Id),Exp))
FunBind : FunMatch                                         ([makeMatchList FunMatch])
        | CurriedFun                                       ([uncurryIt CurriedFun])
        | FunBind And FunBind                              (FunBind1@FunBind2)
FunMatch : Id Pat Equals Exp                               ([(Id,Pat,Exp)])
         | Id Pat Equals Exp VerticalBar FunMatch          ((Id,Pat,Exp)::FunMatch)
CurriedFun :
           Id PatternSeq Equals Exp                        ([(Id,PatternSeq,Exp)])
         | Id PatternSeq Equals Exp VerticalBar CurriedFun ((Id,PatternSeq,Exp)::CurriedFun)
Con : Int                                                  (int(Int))
    | Char                                                 (ch(Char))
    | String                                               (str(String))
    | True                                                 (boolval(&quot;true&quot;))
    | False                                                (boolval(&quot;false&quot;))
    | LParen RParen                                        (tuplecon([]))
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.6, 6.7, 6.8, 6.9</strong> mlcomp.grm</p>
</div>
</div></blockquote>
</div>
<div class="section" id="example-6-4">
<h3>6.3.2. Example 6.4<a class="headerlink" href="#example-6-4" title="Permalink to this headline">¶</a></h3>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="n">*</span> <span class="n">x</span> <span class="n">+</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="exercise docutils container">
<p><strong>Practice 6.3</strong></p>
<p>What modifications would be required in the <em>mlcomp.grm</em> specification to parse expressions like the one below?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case x of
   1 =&gt; &quot;hello&quot;
 | 2 =&gt; &quot;how&quot;
 | 3 =&gt; &quot;are&quot;
 | 4 =&gt; &quot;you&quot;
</pre></div>
</div>
<p><a class="reference internal" href="#exercise6-3"><span class="std std-ref">You can check your answer(s) here.</span></a></p>
</div>
</div>
</div>
<div class="section" id="compiling-and-running-the-compiler">
<h2>6.4. Compiling and Running the Compiler<a class="headerlink" href="#compiling-and-running-the-compiler" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="n">+</span> <span class="mi">4</span>
</pre></div>
</div>
<p><strong>Fig. 6.10</strong> SML Addition</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, 5, 4
BEGIN
    LOAD_CONST 1
    LOAD_CONST 2
    BINARY_ADD
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.11</strong> CoCo Addition</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>infixexp(&quot;+&quot;, int(&quot;5&quot;),
              int(&quot;4&quot;))
</pre></div>
</div>
<p><strong>Fig. 6.12</strong> Addition AST</p>
</div>
<div class="section" id="example-6-5">
<h3>6.4.1. Example 6.5<a class="headerlink" href="#example-6-5" title="Permalink to this headline">¶</a></h3>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">fun</span> <span class="nf">codegen</span><span class="p">(</span><span class="n">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">consts</span><span class="p">,...)</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">index</span> <span class="p">=</span> <span class="n">lookupIndex</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">consts</span><span class="p">)</span>
    <span class="kr">in</span>
      <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent^</span><span class="s2">&quot;LOAD_CONST &quot;</span><span class="n">^index^</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="kr">end</span>
  <span class="p">|</span> <span class="nf">codegen</span><span class="p">(</span><span class="n">infixexp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">consts</span><span class="p">,...)</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="p">_</span> <span class="p">=</span> <span class="n">codegen</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">consts</span><span class="p">,...)</span>
        <span class="kr">val</span> <span class="p">_</span> <span class="p">=</span> <span class="n">codegen</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">consts</span><span class="p">,...)</span>
    <span class="kr">in</span>
      <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent^</span><span class="s2">&quot;BINARY_ADD</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.13</strong> Addition code generation</p>
</div>
</div>
<div class="section" id="example-6-6">
<h3>6.4.2. Example 6.6<a class="headerlink" href="#example-6-6" title="Permalink to this headline">¶</a></h3>
<div class="figboxcenter docutils container">
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nb">set</span> -f
<span class="nb">export</span> <span class="nv">file</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>
<span class="k">if</span> <span class="o">[</span> -z <span class="nv">$file</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> -n <span class="s2">&quot;Enter a file name: &quot;</span>
  <span class="nb">read</span> file
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span> -e <span class="nv">$file</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  rm a.casm &gt;<span class="p">&amp;</span> /dev/null
  rm a.term &gt;<span class="p">&amp;</span> /dev/null
  <span class="nb">echo</span> ******* Source File ********
  cat <span class="nv">$file</span>
  sml @SMLload<span class="o">=</span>mlcompimage <span class="nv">$file</span>
  <span class="nb">echo</span> * Target Program Execution *
  coco a.casm
<span class="k">else</span>
  <span class="nb">echo</span> FILE DOES NOT EXIST
<span class="k">fi</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.14</strong> The mlcomp script</p>
</div>
<div class="figbox docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span>fun compile filename  =
    let val (ast, _) = parse filename
        val outFile = TextIO.openOut(&quot;a.casm&quot;)
        val termFile = TextIO.openOut(&quot;a.term&quot;)
        val _ = writeTerm(termFile,ast)
        val _ = TextIO.closeOut(termFile)
        val consts = removeDups (&quot;None&quot;::&quot;&#39;Match Not Found&#39;&quot;::&quot;0&quot;::(constants ast))
        val globalBindings = [(&quot;println&quot;,&quot;print&quot;),...]
        val (newbindings,freeVars,cells) = localBindings(ast,[],globalBindings,0)
        val bindingVars = removeDups (List.map (fn x =&gt; #2(x)) newbindings)
        val cellVars = List.map (fn x =&gt; boundTo(x,newbindings@globalBindings)) cells
        val locals = listdiff bindingVars cellVars
        val globals = removeDups (List.map (fn (x,y) =&gt; y) globalBindings)
    in
      if length(freeVars) &lt;&gt; 0 then
         (TextIO.output(TextIO.stdOut,
            &quot;Error: Unbound variable(s) found in main expression =&gt; &quot; ^
            (commaSepList freeVars) ^ &quot;.\n&quot;);
          raise notFound)
      else ();
      TextIO.output(outFile,&quot;Function: main/0\n&quot;);
      nestedfuns(ast,outFile,&quot;    &quot;,globals,[],globalBindings,0);
      TextIO.output(outFile,&quot;Constants: &quot;^(commaSepList consts) ^ &quot;\n&quot;);
      if not (List.null(locals)) then
        TextIO.output(outFile,&quot;Locals: &quot;^(commaSepList locals) ^ &quot;\n&quot;)
      else ();
      if not (List.null(cellVars)) then
        TextIO.output(outFile,&quot;CellVars: &quot;^(commaSepList cellVars) ^ &quot;\n&quot;)
      else ();
      TextIO.output(outFile,&quot;Globals: &quot;^(commaSepList globals) ^ &quot;\n&quot;);
      TextIO.output(outFile,&quot;BEGIN\n&quot;);
      makeFunctions(ast,outFile,&quot;    &quot;,consts,...);
      codegen(ast,outFile,&quot;    &quot;,consts,...);
      TextIO.output(outFile,&quot;    POP_TOP\n&quot;);
      TextIO.output(outFile,&quot;    LOAD_CONST 0\n&quot;);
      TextIO.output(outFile,&quot;    RETURN_VALUE\n&quot;);
      TextIO.output(outFile,&quot;END\n&quot;);
      TextIO.closeOut(outFile)
    end
    handle _ =&gt; (TextIO.output(TextIO.stdOut,
                   &quot;An error occurred while compiling!\n\n&quot;));
 fun run(a,b::c) = (compile b; OS.Process.success)
   | run(a,b) = (TextIO.print(&quot;usage: sml @SMLload=mlcomp\n&quot;);
                 OS.Process.success)
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.15</strong> MLComp Run Function</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
sml <span class="s">&lt;&lt; EOF</span>
<span class="s">CM.make &quot;sources.cm&quot;;</span>
<span class="s">SMLofNJ.exportFn(&quot;mlcompimage&quot;,mlcomp.run);</span>
<span class="s">EOF</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.16</strong> Makefile.gen</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Group is
  $/ml-yacc-lib.cm
  $/basis.cm
  $smlnj-tdp/back-trace.cm
  mlcomp.lex
  mlcomp.grm
  mlcomp.sml
  mlast.sml
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.17</strong> sources.cm</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>make
mlcomp test0.sml
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-calls">
<h2>6.5. Function Calls<a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, &#39;Match Not Found&#39;, 0, 5, 4
Globals: print, fprint, input, int, len,
         type, Exception, funlist, concat
BEGIN
    LOAD_GLOBAL 0
    LOAD_CONST 3
    LOAD_CONST 4
    BINARY_ADD
    CALL_FUNCTION 1
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.18</strong> test1.sml CoCo Code</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>apply(id(&quot;println&quot;),infixexp(&quot;+&quot;,int(&quot;5&quot;),int(&quot;4&quot;)))
</pre></div>
</div>
<div class="figbox docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>| codegen(id(name),outFile,indent,consts,...,globals,env,globalBindings,...) =
    load(name,outFile,indent,locals,freeVars,cellVars,globals,globalBindings,env)
| codegen(apply(t1,t2),outFile,indent,consts,...,globals,env,globalBindings,...) =
    let val _ = codegen(t1,outFile,indent,consts,l...,globals,env,globalBindings,...)
        val _ = codegen(t2,outFile,indent,consts,...,globals,env,globalBindings,...)
    in
       TextIO.output(outFile,indent^&quot;CALL_FUNCTION 1\n&quot;)
    end
</pre></div>
</td></tr></table></div>
</div>
<p><strong>Fig. 6.19</strong> Code Generation for Function Calls</p>
</div>
<div class="section" id="let-expressions">
<h2>6.6. Let Expressions<a class="headerlink" href="#let-expressions" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="n">x</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.20</strong> test2.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, &#39;Match Not Found&#39;,
           0, 5
Locals: x@0
Globals: print, ...
BEGIN
    LOAD_CONST 3
    STORE_FAST 0
    LOAD_GLOBAL 0
    LOAD_FAST 0
    CALL_FUNCTION 1
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.21</strong> test2.sml CoCo Code</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>letdec(bindval(idpat(&quot;x&quot;),int(&quot;5&quot;)),
       [apply(id(&quot;println&quot;),id(&quot;x&quot;))])
</pre></div>
</div>
<div class="figbox docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">|</span> <span class="n">codegen</span><span class="p">(</span><span class="n">letdec</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">L2</span><span class="p">),...,</span><span class="n">consts</span><span class="p">,</span><span class="n">locals</span><span class="p">,...,</span><span class="n">globals</span><span class="p">,</span><span class="n">env</span><span class="p">,</span><span class="n">globalBindings</span><span class="p">,</span><span class="n">scope</span><span class="p">)</span> <span class="p">=</span>
  <span class="kr">let</span> <span class="kr">val</span> <span class="nv">newbindings</span> <span class="p">=</span> <span class="n">decgen</span><span class="p">(</span><span class="n">d</span><span class="p">,...,</span><span class="n">consts</span><span class="p">,</span><span class="n">locals</span><span class="p">,...,</span><span class="n">globals</span><span class="p">,</span><span class="n">env</span><span class="p">,</span><span class="n">globalBindings</span><span class="p">,</span><span class="n">scope</span><span class="p">)</span>
  <span class="kr">in</span>
    <span class="n">codegenseq</span><span class="p">(</span><span class="n">L2</span><span class="p">,...,</span><span class="n">consts</span><span class="p">,</span><span class="n">locals</span><span class="p">,...,</span><span class="n">globals</span><span class="p">,</span><span class="n">newbindings@env</span><span class="p">,</span><span class="n">globalBindings</span><span class="p">,</span><span class="n">scope+</span><span class="mi">1</span><span class="p">)</span>
  <span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.22</strong> Let Expression Code Generation</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">6</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">x</span> <span class="n">+</span> <span class="n">y</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.23</strong> test10.sml</p>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">|</span> <span class="n">Let</span> <span class="n">DecSeq</span> <span class="n">In</span> <span class="n">ExpSequence</span> <span class="n">End</span>
    <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">foldr</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="n">letdec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)])</span> <span class="n">ExpSequence</span> <span class="n">DecSeq</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.24</strong> The folded set</p>
</div>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
<span class="kr">in</span>
  <span class="kr">let</span> <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">6</span>
  <span class="kr">in</span>
    <span class="n">println</span> <span class="p">(</span><span class="n">x</span> <span class="n">+</span> <span class="n">y</span><span class="p">)</span>
  <span class="kr">end</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.25</strong> Unsweetened</p>
</div>
</div>
<div class="section" id="unary-negation">
<h2>6.7. Unary Negation<a class="headerlink" href="#unary-negation" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="n">~x</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.26</strong> test3.sml</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{tilde} =&gt; (Tokens.Negate(!pos,!pos));
{digit}+({period}{digit}+)?  =&gt; (Tokens.Int(yytext,!pos,!pos));
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%term EOF
    | Negate
    | ...
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%right ListCons Negate
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| Negate Exp         (negate(Exp))
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| negate of exp
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| nameOf(infixexp(operator,e1,e2)) = operator
| nameOf(negate(e)) = &quot;~&quot;
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| con(infixexp(operator,t1,t2)) = (con t1) @ (con t2)
| con(negate(e)) = &quot;0&quot; :: (con e)
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| bindingsOf(infixexp(operator,exp1,exp2),bindings,scope) =
        (bindingsOf(exp1,bindings,scope); bindingsOf(exp2,bindings,scope))
| bindingsOf(negate(exp),bindings,scope) = bindingsOf(exp,bindings,scope)
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| codegen(negate(t),outFile,indent,consts,...) =
  let val _ = codegen(int(&quot;0&quot;),outFile,indent,consts,...)
      val _ = codegen(t,outFile,indent,consts,...)
  in
    TextIO.output(outFile,indent^&quot;BINARY_SUBTRACT\n&quot;)
  end
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| functions(infixexp(operator,exp1,exp2)) = (functions exp1;functions exp2)
| functions(negate(exp)) = functions exp
</pre></div>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, &#39;Match Not Found&#39;, 5, 0
Locals: x@0
Globals: print, ...
    LOAD_CONST 2
    STORE_FAST 0
    LOAD_GLOBAL 0
    LOAD_CONST 3
    LOAD_FAST 0
    BINARY_SUBTRACT
    CALL_FUNCTION 1
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.27</strong> test3.sml JCoCo Code</p>
</div>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>| writeExp(indent,negate(exp)) =
          (print(&quot;negate(&quot;);
           writeExp(indent,exp);
           print(&quot;)&quot;))
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="if-then-else-expressions">
<h2>6.8. If-Then-Else Expressions<a class="headerlink" href="#if-then-else-expressions" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">fromString</span><span class="p">(</span>
            <span class="n">input</span><span class="p">(</span><span class="s2">&quot;Please enter an integer: &quot;</span><span class="p">))</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="nn">Int</span><span class="p">.</span><span class="n">fromString</span><span class="p">(</span>
            <span class="n">input</span><span class="p">(</span><span class="s2">&quot;Please enter an integer: &quot;</span><span class="p">))</span>
<span class="kr">in</span>
  <span class="n">print</span> <span class="s2">&quot;The maximum is &quot;</span><span class="p">;</span>
  <span class="n">println</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="n">&gt;</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">y</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.28</strong> test4.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, &#39;Match Not Found&#39;,
  0, &quot;Please enter an integer: &quot;,
  &quot;The maximum is &quot;
Locals: y@1, x@0
Globals: print, fprint, input, int, len,
  type, Exception, funlist, concat
BEGIN
    LOAD_GLOBAL 3
    LOAD_GLOBAL 2
    LOAD_CONST 3
    CALL_FUNCTION 1
    CALL_FUNCTION 1
    STORE_FAST 1
    LOAD_GLOBAL 3
    LOAD_GLOBAL 2
    LOAD_CONST 3
    CALL_FUNCTION 1
    CALL_FUNCTION 1
    STORE_FAST 0
    LOAD_GLOBAL 1
    LOAD_CONST 4
    CALL_FUNCTION 1
    POP_TOP
    LOAD_GLOBAL 0
    LOAD_FAST 1
    LOAD_FAST 0
    COMPARE_OP 4
    POP_JUMP_IF_FALSE L0
    LOAD_FAST 1
    JUMP_FORWARD L1
L0:
    LOAD_FAST 0
L1:
    CALL_FUNCTION 1
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.29</strong> test4.sml JCoCo Code</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ifthen(infixexp(&quot;&gt;&quot;,id(&quot;x&quot;),id(&quot;y&quot;)),id(&quot;x&quot;),id(&quot;y&quot;))
</pre></div>
</div>
</div>
<div class="section" id="short-circuit-logic">
<h2>6.9. Short-Circuit Logic<a class="headerlink" href="#short-circuit-logic" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">true</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">false</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">x</span> <span class="kr">orelse</span> <span class="n">y</span> <span class="n">div</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">y</span> <span class="kr">andalso</span> <span class="n">x</span> <span class="n">*</span> <span class="mi">5</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.30</strong> test5.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None,
   &#39;Match Not Found&#39;,
   True, False, 0, 5
Locals: y@1, x@0
Globals: print, fprint, input,
   int, len, type, Exception,
   funlist, concat
BEGIN
    LOAD_CONST 2
    STORE_FAST 1
    LOAD_CONST 3
    STORE_FAST 0
    LOAD_GLOBAL 0
    LOAD_FAST 1
    DUP_TOP
    POP_JUMP_IF_TRUE L0
    POP_TOP
    LOAD_FAST 0
    LOAD_CONST 4
    BINARY_FLOOR_DIVIDE
L0:
    CALL_FUNCTION 1
    POP_TOP
    LOAD_GLOBAL 0
    LOAD_FAST 0
    DUP_TOP
    POP_JUMP_IF_FALSE L1
    POP_TOP
    LOAD_FAST 1
    LOAD_CONST 5
    BINARY_MULTIPLY
L1:
    CALL_FUNCTION 1
    POP_TOP
    LOAD_CONST 0
    RETURN_VALUE
END
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.31</strong> test5.sml JCoCo Code</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>infixexp(&quot;orelse&quot;,id(&quot;x&quot;),infixexp(&quot;div&quot;,id(&quot;y&quot;),int(&quot;0&quot;)))
infixexp(&quot;andalso&quot;,id(&quot;y&quot;),infixexp(&quot;*&quot;,id(&quot;x&quot;),int(&quot;5&quot;)))
</pre></div>
</div>
</div>
<div class="section" id="defining-functions">
<h2>6.10. Defining Functions<a class="headerlink" href="#defining-functions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span><span class="s2">&quot;Function: main/0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="n">nestedfuns</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span><span class="n">outFile</span><span class="p">,</span><span class="s2">&quot;    &quot;</span><span class="p">,</span><span class="n">globals</span><span class="p">,[],</span><span class="n">globalBindings</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| Fn MatchExp (func(nextIdNum(),MatchExp))
</pre></div>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">fun</span> <span class="nf">factorial</span> <span class="mi">0</span> <span class="p">=</span> <span class="mi">1</span>
      <span class="p">|</span> <span class="nf">factorial</span> <span class="n">n</span> <span class="p">=</span> <span class="n">n</span> <span class="n">*</span> <span class="p">(</span><span class="n">factorial</span> <span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">))</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">factorial</span> <span class="mi">5</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.32</strong> test6.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
    Function: factorial/1
    Constants: None,
        &#39;Match Not Found&#39;, 0, 1
    Locals: factorial@Param, n@1
    FreeVars: factorial
    Globals: print, fprint, input,
        int, len, type, Exception,
        funlist, concat
    BEGIN
        LOAD_FAST 0
        LOAD_CONST 2
        COMPARE_OP 2
        POP_JUMP_IF_FALSE L0
        LOAD_CONST 3
        RETURN_VALUE
L0:
        LOAD_FAST 0
        STORE_FAST 1
        LOAD_FAST 1
        LOAD_DEREF 0
        LOAD_FAST 1
        LOAD_CONST 3
        BINARY_SUBTRACT
        CALL_FUNCTION 1
        BINARY_MULTIPLY
        RETURN_VALUE
L1:
        LOAD_GLOBAL 6
        LOAD_CONST 1
        CALL_FUNCTION 1
        RAISE_VARARGS 1
    END
...
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.33</strong> test6.sml JCoCo Code</p>
</div>
<div class="section" id="curried-functions">
<h3>6.10.1. Curried Functions<a class="headerlink" href="#curried-functions" title="Permalink to this headline">¶</a></h3>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span>
  <span class="kr">fun</span> <span class="nf">append</span> <span class="n">nil</span> <span class="n">L</span> <span class="p">=</span> <span class="n">L</span>
    <span class="p">|</span> <span class="nf">append</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="n">L</span> <span class="p">=</span> <span class="n">h</span> <span class="n">::</span> <span class="p">(</span><span class="n">append</span> <span class="n">t</span> <span class="n">L</span><span class="p">)</span>

  <span class="kr">fun</span> <span class="nf">appendOne</span> <span class="n">x</span> <span class="p">=</span>
    <span class="p">(</span><span class="kr">fn</span> <span class="n">nil</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">L</span> <span class="p">=&gt;</span> <span class="n">L</span><span class="p">)</span>
     <span class="n">|</span> <span class="n">h::t</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">L</span> <span class="p">=&gt;</span> <span class="n">h</span> <span class="n">::</span> <span class="p">(</span><span class="n">appendOne</span> <span class="n">t</span> <span class="n">L</span><span class="p">)))</span> <span class="n">x</span>
<span class="kr">in</span>
  <span class="n">println</span><span class="p">(</span><span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
  <span class="n">println</span><span class="p">(</span><span class="n">appendOne</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.34</strong> test7.sml</p>
</div>
<div class="figbox docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">exception</span> <span class="nc">emptyDecList</span><span class="p">;</span>
<span class="kr">exception</span> <span class="nc">argumentMismatch</span><span class="p">;</span>
<span class="kr">fun</span> <span class="nf">uncurryIt</span> <span class="n">nil</span> <span class="p">=</span> <span class="kr">raise</span> <span class="n">emptyDecList</span>
  <span class="p">|</span> <span class="nf">uncurryIt</span> <span class="p">(</span><span class="n">L</span> <span class="kr">as</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">patList</span><span class="p">,</span><span class="n">exp</span><span class="p">)</span><span class="n">::t</span><span class="p">))</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">fun</span> <span class="nf">len</span> <span class="n">nil</span> <span class="p">=</span> <span class="kr">raise</span> <span class="n">argumentMismatch</span>
          <span class="p">|</span> <span class="nf">len</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)]</span> <span class="p">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
          <span class="p">|</span> <span class="nf">len</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)</span><span class="n">::t</span><span class="p">)</span> <span class="p">=</span>
            <span class="kr">let</span> <span class="kr">val</span> <span class="nv">size</span> <span class="p">=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="kr">in</span>
              <span class="kr">if</span> <span class="n">size</span> <span class="p">=</span> <span class="n">len</span> <span class="n">t</span> <span class="kr">then</span> <span class="n">size</span> <span class="kr">else</span>
                <span class="p">(</span><span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="nn">TextIO</span><span class="p">.</span><span class="n">stdOut</span><span class="p">,</span>
                  <span class="s2">&quot;Syntax Error: Number of arguments does not match in function &quot;</span><span class="n">^name^</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
                 <span class="kr">raise</span> <span class="n">argumentMismatch</span><span class="p">)</span>
            <span class="kr">end</span>
        <span class="kr">val</span> <span class="nv">tupleList</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="s2">&quot;v&quot;</span><span class="n">^</span><span class="nn">Int</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="n">nextIdNum</span><span class="p">()))</span> <span class="n">patList</span>
     <span class="kr">in</span>
       <span class="n">len</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="cm">(* just check the paramter list sizes so all patterns have same length *)</span>
       <span class="p">(</span><span class="n">name</span><span class="p">,[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">hd</span><span class="p">(</span><span class="n">tupleList</span><span class="p">)),</span>
                 <span class="nn">List</span><span class="p">.</span><span class="n">foldr</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">func</span><span class="p">(</span><span class="n">nextIdNum</span><span class="p">(),[</span><span class="n">match</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)]))</span>
                    <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">nextIdNum</span><span class="p">(),</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">match</span><span class="p">(</span><span class="n">tuplepat</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">e</span><span class="p">))</span> <span class="n">L</span><span class="p">),</span>
                            <span class="n">tuplecon</span><span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">id</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="n">tupleList</span><span class="p">)))</span> <span class="p">(</span><span class="n">tl</span> <span class="n">tupleList</span><span class="p">))])</span>
     <span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.35</strong> The uncurryIt Function</p>
</div>
</div>
<div class="section" id="mutually-recursive-functions">
<h3>6.10.2. Mutually Recursive Functions<a class="headerlink" href="#mutually-recursive-functions" title="Permalink to this headline">¶</a></h3>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">fun</span> <span class="nf">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">y</span>
      <span class="p">|</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x*y</span><span class="p">)</span>
    <span class="kr">and</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="kr">in</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.36</strong> test11.sml</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>letdec(funmatches([funmatch(&quot;f&quot;,f&#39;s body),funmatch(&quot;g&quot;,g&#39;s body)]))
</pre></div>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">|</span> <span class="n">dec</span><span class="p">(</span><span class="n">funmatches</span><span class="p">(</span><span class="n">L</span><span class="p">))</span> <span class="p">=</span>
  <span class="kr">let</span> <span class="kr">val</span> <span class="nv">nameList</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">matchlist</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">name</span><span class="p">)</span> <span class="n">L</span>
  <span class="kr">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">matchList</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">adjustedBindings</span> <span class="p">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> <span class="p">(</span><span class="n">listdiff</span> <span class="n">nameList</span> <span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="kr">in</span>
      <span class="n">nestedfun</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">matchList</span><span class="p">,</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">globals</span><span class="p">,</span><span class="n">adjustedBindings@env</span><span class="p">,</span><span class="n">globalBindings</span><span class="p">,</span><span class="n">scope</span><span class="p">)</span>
    <span class="kr">end</span><span class="p">)</span> <span class="n">L</span><span class="p">;</span>
    <span class="p">()</span>
  <span class="kr">end</span>

<span class="n">**Fig</span> <span class="mf">6.37</span><span class="n">**</span> <span class="n">Mutually</span> <span class="n">recursive</span> <span class="n">function</span> <span class="n">declarations</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="reference-variables">
<h2>6.11. Reference Variables<a class="headerlink" href="#reference-variables" title="Permalink to this headline">¶</a></h2>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="kr">in</span>
  <span class="n">x</span> <span class="n">:=</span> <span class="n">!x</span> <span class="n">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">println</span> <span class="p">(</span><span class="n">!x</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.38</strong> test8.sml</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| Exclaim Exp     (apply(id(&quot;!&quot;),Exp))
| Id SetEqual FuncExp (infixexp(&quot;:=&quot;,id(Id),FuncExp))
</pre></div>
</div>
<p><strong>Fig. 6.39</strong> Set equal and deref operators</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">and</span> <span class="nv">decbindingsOf</span><span class="p">(</span><span class="n">bindval</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">apply</span><span class="p">(</span><span class="n">id</span><span class="p">(</span><span class="s2">&quot;ref&quot;</span><span class="p">),</span><span class="n">exp</span><span class="p">)),</span><span class="n">bindings</span><span class="p">,</span><span class="n">scope</span><span class="p">)</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">newbindings</span> <span class="p">=</span> <span class="n">patBindings</span><span class="p">(</span><span class="n">idpat</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">scope</span><span class="p">)</span>
        <span class="kr">val</span> <span class="nv">newcellvar</span> <span class="p">=</span> <span class="n">name^</span><span class="s2">&quot;@&quot;</span><span class="n">^</span><span class="nn">Int</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
    <span class="kr">in</span>
      <span class="n">bindingsOf</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span><span class="n">newbindings@bindings</span><span class="p">,</span><span class="n">scope+</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">addIt</span><span class="p">(</span><span class="n">newcellvar</span><span class="p">,</span><span class="n">cellVars</span><span class="p">);</span>
      <span class="p">[</span><span class="n">addIt</span><span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">newcellvar</span><span class="p">),</span><span class="n">theBindings</span><span class="p">)]</span>
    <span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.40</strong> Reference variable bindings</p>
</div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">|</span> <span class="n">codegen</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">id</span><span class="p">(</span><span class="s2">&quot;ref&quot;</span><span class="p">),</span><span class="n">t2</span><span class="p">),...)</span> <span class="p">=</span>
      <span class="n">codegen</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">outFile</span><span class="p">,...)</span>
<span class="n">|</span> <span class="n">codegen</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">id</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span><span class="n">t2</span><span class="p">),...)</span> <span class="p">=</span>
      <span class="n">codegen</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">outFile</span><span class="p">,...)</span>
<span class="n">|</span> <span class="n">codegen</span><span class="p">(</span><span class="n">infixexp</span><span class="p">(</span><span class="s2">&quot;:=&quot;</span><span class="p">,</span><span class="n">id</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">t2</span><span class="p">),...)</span> <span class="p">=</span>
  <span class="kr">let</span> <span class="kr">val</span> <span class="p">_</span> <span class="p">=</span> <span class="n">codegen</span><span class="p">(</span><span class="n">t2</span><span class="p">,...)</span>
      <span class="kr">val</span> <span class="nv">noneIndex</span> <span class="p">=</span>
            <span class="n">lookupIndex</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span><span class="n">consts</span><span class="p">)</span>
  <span class="kr">in</span>
    <span class="n">store</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">outFile</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">locals</span><span class="p">,,...);</span>
    <span class="nn">TextIO</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">outFile</span><span class="p">,</span>
        <span class="n">indent^</span><span class="s2">&quot;LOAD_CONST &quot;</span><span class="n">^noneIndex^</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.41</strong> Variable Code Generation</p>
</div>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>| bindingsOf(id(&quot;!&quot;),bindings,scope) = ()
</pre></div>
</td></tr></table></div>
<div class="figboxcenter docutils container">
<div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kr">fun</span> <span class="nf">f</span> <span class="n">y</span> <span class="p">=</span> <span class="p">(</span><span class="n">x:=!x+</span><span class="mi">1</span><span class="p">)</span>
<span class="kr">in</span>
  <span class="n">f</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">println</span> <span class="n">x</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
<p><strong>Fig. 6.42</strong> test9.sml</p>
</div>
</div>
<div class="section" id="chapter-summary">
<h2>6.12. Chapter Summary<a class="headerlink" href="#chapter-summary" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="review-questions">
<h2>6.13. Review Questions<a class="headerlink" href="#review-questions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The language of regular expressions can be used to define the tokens of a language. Give an example for a regular expression from the chapter and indicate what kind of tokens it represents.</p>
</li>
<li><p class="first">What does ML-lex do? What input does it require? What does it produce?</p>
</li>
<li><p class="first">What does ML-yacc do? What input does it require? What does it produce?</p>
</li>
<li><p class="first">How is an abstract syntax tree declared in ML?</p>
<blockquote>
<div><div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">fun</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="n">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="mi">~1</span><span class="n">*x</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="exercises">
<h2>6.14. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Modify the compiler to support unary negation as described in this chapter. Upon completion <em>test3.sml</em> should compile and run correctly.</p>
</li>
<li><p class="first">Add &gt;=, &lt;=, and &lt;&gt; (not equal) operators to the Small language. Provide all the pieces in all the files so programs using these operators can be compiled. Write a Small program that demonstrates that this functionality works.</p>
</li>
<li><p class="first">Add support for <em>if-then-else</em> expressions to the Small compiler as described in this chapter. Follow the instructions of the chapter and be sure to test your implementation using <em>test4.sml</em>.</p>
</li>
<li><p class="first">Implement short-circuit logic as described in this chapter for the <em>andalso</em> and the <em>orelse</em> operators.</p>
</li>
<li><p class="first">Follow the step in this chapter to add support for compiling expressions with variables. Then, implement a <em>while do</em> loop for the <em>mlcomp</em> compiler. A while loop is written <em>while Exp1 do Exp2</em>. The <em>Exp1</em> expression is evaluated first to see if it yields true. If it does, then <em>Exp2</em> is evaluated. This repeats until <em>Exp2</em> returns false. Remember your job is to generate code for a while loop, not execute it. Use examples like adding <em>if-then-else</em> to help you determine where the changes need to be made to add support for <em>while do</em> loops. Successfully writing this code will result in successfully compiling and running test12.sml.</p>
</li>
<li><p class="first">Add support for <em>case</em> expressions in the <em>mlcomp</em> Small compiler. The concrete syntax of a case statement is</p>
<blockquote>
<div><div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">Expression</span> <span class="p">:</span> <span class="p">...</span>
  <span class="n">|</span> <span class="n">Case</span> <span class="n">Exp</span> <span class="n">Of</span> <span class="n">MatchExp</span>  <span class="p">(</span><span class="n">caseof</span><span class="p">(</span><span class="n">Exp</span><span class="p">,</span><span class="n">MatchExp</span><span class="p">))</span>
</pre></div>
</div>
</div></blockquote>
<p>while the abstract syntax of a case expression is given here.</p>
<blockquote>
<div><div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">caseof</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
</pre></div>
</div>
</div></blockquote>
<p>Follow an example like adding support for unary negation to see what all is required to support the <em>case</em> expression in CoCo. Write a program to test the use of the <em>case</em> expression in your code. There is currently no support for case expressions in the mlcomp compiler. This project will require you to add support to all facets of the compiler including the scanner, parser, and code generator. When you have successfully implemented the code to parse and compile case expressions, you will be able to compile this program which is test15.sml in the mlcomp distribution.</p>
<blockquote>
<div><div class="highlight-sml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">4</span>
<span class="kr">in</span>
  <span class="n">println</span>
    <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
      <span class="mi">1</span> <span class="p">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
    <span class="n">|</span> <span class="mi">2</span> <span class="p">=&gt;</span> <span class="s2">&quot;how&quot;</span>
    <span class="n">|</span> <span class="mi">3</span> <span class="p">=&gt;</span> <span class="s2">&quot;are&quot;</span>
    <span class="n">|</span> <span class="mi">4</span> <span class="p">=&gt;</span> <span class="s2">&quot;you&quot;</span>
<span class="kr">end</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The generated code for this program is given below. The program, when run, will print <em>you</em> to the screen.</p>
<blockquote>
<div><div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Function: main/0
Constants: None, &#39;Match Not Found&#39;, 0, 1, &quot;hello&quot;, 2, &quot;how&quot;, 3, &quot;are&quot;, 4, &quot;you&quot;
Locals: x@0
Globals: print, fprint, input, int, len, type, Exception, funlist, concat
BEGIN
    LOAD_CONST 9     # Here the 6 is stored in x.
    STORE_FAST 0
    LOAD_GLOBAL 0    # This is the println pushed onto stack.
    LOAD_FAST 0      # x is loaded onto stack.
    DUP_TOP          # Case expression code where x&#39;s value is duplicated.
    LOAD_CONST 3     # This is a pattern match for the first pattern.
    COMPARE_OP 2
    POP_JUMP_IF_FALSE L1
    POP_TOP          # Case expression code to pop x from stack
    LOAD_CONST 4     # This is the expression for the first match.
    JUMP_FORWARD L0  # Case expression code to jump to end of case.
L1:                  # Case expression code for label for end of first pattern.
    DUP_TOP          # Case expression code where x&#39;s value is duplicated.
    LOAD_CONST 5     # This is a pattern match for the second pattern.
    COMPARE_OP 2
    POP_JUMP_IF_FALSE L2
    POP_TOP          # Case expression code to pop x from stack
    LOAD_CONST 6     # This is the expression for the second match.
    JUMP_FORWARD L0  # Case expression code to jump to end of case.
L2:                  # Case expression code for label for end of second pattern.
    DUP_TOP          # Case expression code where x&#39;s value is duplicated.
    LOAD_CONST 7     # This is a pattern match for the third pattern.
    COMPARE_OP 2
    POP_JUMP_IF_FALSE L3
    POP_TOP          # Case expression code to pop x from stack
    LOAD_CONST 8     # This is the expression for the third match.
    JUMP_FORWARD L0  # Case expression code to jump to end of case.
L3:                  # Case expression code for label for end of third pattern.
    DUP_TOP          # Case expression code where x&#39;s value is duplicated.
    LOAD_CONST 9     # This is a pattern match for the fourth pattern.
    COMPARE_OP 2
    POP_JUMP_IF_FALSE L4
    POP_TOP          # Case expression code to pop x from stack
    LOAD_CONST 10    # This is the expression for the fourth match.
    JUMP_FORWARD L0  # Case expression code to jump to end of case.
L4:                  # Case expression code for label for end of fourth pattern.
L0:                  # This is the end of case expression label.
    CALL_FUNCTION 1  # print the result which was left on the stack
    POP_TOP          # Pop the None left by println
    LOAD_CONST 0     # Push a None to return
    RETURN_VALUE     # Return the None
END
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">The following program does not compile correctly using the mlcomp compiler and type inference system. However, it is a valid Standard ML program. Modify the mlcomp compiler to correctly compile this program.</p>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="kr">val</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)]</span> <span class="p">=</span> <span class="p">[(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">true</span><span class="p">)]</span> <span class="kr">in</span> <span class="n">println</span> <span class="n">x</span> <span class="kr">end</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="solutions-to-practice-problems">
<h2>6.15. Solutions to Practice Problems<a class="headerlink" href="#solutions-to-practice-problems" title="Permalink to this headline">¶</a></h2>
<p>These are solutions to the practice problem s. You should only consult these answers after you have tried each of them for yourself first. Practice problems  are meant to help reinforce the material you have just read so make use of them.</p>
<div class="section" id="solution-to-practice-problem-6-1">
<span id="exercise6-1"></span><h3>6.15.1. Solution to Practice Problem 6.1<a class="headerlink" href="#solution-to-practice-problem-6-1" title="Permalink to this headline">¶</a></h3>
<p>The keywords <em>case</em> and <em>of</em> must be added to the scanner specification in <em>mlcomp.lex</em>. All the other tokens are already available in the scanner.</p>
</div>
<div class="section" id="solution-to-practice-problem-6-2">
<span id="exercise6-2"></span><h3>6.15.2. Solution to Practice Problem 6.2<a class="headerlink" href="#solution-to-practice-problem-6-2" title="Permalink to this headline">¶</a></h3>
<p>You need to add a new AST node type.</p>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">|</span> <span class="n">caseof</span> <span class="kr">of</span> <span class="n">exp</span> <span class="n">*</span> <span class="n">match</span> <span class="n">list</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-to-practice-problem-6-3">
<span id="exercise6-3"></span><h3>6.15.3. Solution to Practice Problem 6.3<a class="headerlink" href="#solution-to-practice-problem-6-3" title="Permalink to this headline">¶</a></h3>
<p>The grammar changes required for case expressions are as follows.</p>
<div class="highlight-sml notranslate"><div class="highlight"><pre><span></span><span class="n">Expression</span> <span class="p">:</span> <span class="p">...</span>
  <span class="n">|</span> <span class="n">Case</span> <span class="n">Exp</span> <span class="n">Of</span> <span class="n">MatchExp</span>  <span class="p">(</span><span class="n">caseof</span><span class="p">(</span><span class="n">Exp</span><span class="p">,</span><span class="n">MatchExp</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="prolog.html" title="7. Prolog"
             >next</a> |</li>
        <li class="right" >
          <a href="functional.html" title="5. Standard ML"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Foundations of Programming Languages Second Edition</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Kent D. Lee.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.3.
    </div>
  </body>
</html>